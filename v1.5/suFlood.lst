CCS PCM C Compiler, Version 4.121, 53065               26-Aug-12 11:25

               Filename: C:\Users\Paskorn\Dropbox\PICC\v1.5\suFlood.lst

               ROM used: 4382 words (53%)
                         Largest free fragment is 2048
               RAM used: 122 (33%) at main() level
                         241 (65%) worst case
               Stack:    6 worst case (3 in main + 3 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.0
001A:  GOTO   01D
001B:  BTFSC  0C.0
001C:  GOTO   034
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.3
0020:  GOTO   023
0021:  BTFSC  0C.3
0022:  GOTO   037
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   20,W
002E:  MOVWF  0A
002F:  SWAPF  21,W
0030:  MOVWF  03
0031:  SWAPF  7F,F
0032:  SWAPF  7F,W
0033:  RETFIE
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   03A
0037:  BCF    0A.3
0038:  BCF    0A.4
0039:  GOTO   43A
.................... #include <16F886.h> 
.................... //////// Standard Header file for the PIC16F886 device //////////////// 
.................... #device PIC16F886 
.................... #list 
....................  
....................  
....................  
.................... #include <Slave.h> 
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(clock=20000000) 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////   
.................... /// 
.................... ///   D E F I N E    V A L U E S . 
.................... /// 
.................... ///////////////////////////////////////////////////////////// --- Define Values. 
....................  
.................... // commands 
.................... #define PING            1 
.................... #define DISPLAY_NUMBER  2 
.................... #define DISPLAY_TEXT    3 
.................... #define UPDATE_SENSORS  4 
.................... #define DISPLAY_FLOAT   7 
....................  
.................... // slave states 
.................... #define READY_FOR_ADDRESS    1 
.................... #define READY_FOR_CMD        2 
.................... //#define READY_TO_ACK         3 
.................... #define READY_FOR_LETTER      6 
....................  
....................  
.................... #define DISP_STATE_USER          0 
.................... #define DISP_STATE_OFF           1 
.................... #define DISP_STATE_SHOW_SENSOR   3 
....................  
.................... #define TIMEOUT                  10    // 10 is about 1 second 
.................... #define BANNER_DISPLAY_DURATION  10    // 10 is about 1 second 
....................  
....................  
.................... // slave states 
.................... #define READY_FOR_ADDRESS     1 
.................... #define READY_FOR_CMD         2 
.................... #define READY_FOR_NUMBER      3 
.................... #define READY_TO_SEND         4 
.................... #define READY_TO_SEND_BYTE_2  5 
....................  
.................... // Commands from the master 
.................... #define CMD_RECEIVE_A_BYTE_FROM_MASTER  1 
.................... #define CMD_SEND_TWO_BYTES_TO_MASTER  2 
....................  
.................... // Buffer 
.................... #DEFINE MAXSTR    64 
.................... #DEFINE NUMBER    0 
.................... #DEFINE LETTER    1 
.................... #DEFINE FLO       2 
....................  
....................  
.................... //#device adc=10 
....................  
.................... #use delay(clock=20000000) 
.................... #use i2c(SLAVE, SDA=PIN_C4, SCL=PIN_C3, address=0xB0, FORCE_HW) 
*
004A:  MOVF   13,W
004B:  BSF    03.6
004C:  MOVF   38,W
004D:  BCF    03.6
004E:  MOVWF  13
004F:  BSF    14.4
0050:  BCF    0C.3
0051:  BSF    03.5
0052:  BTFSC  14.0
0053:  GOTO   052
0054:  CLRF   78
0055:  BCF    03.5
0056:  BTFSC  14.4
0057:  INCF   78,F
0058:  RETURN
.................... //9#use rs232(baud = 9600, xmit = PIN_C6, rcv = PIN_C7) 
....................  
.................... #FUSES NOWDT //No Watch Dog Timer 
.................... #FUSES HS //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT //No Power Up Timer 
.................... #FUSES MCLR //Master Clear pin enabled 
.................... #FUSES NOPROTECT //Code not protected from reading 
.................... #FUSES NOCPD //No EE protection 
.................... #FUSES NOBROWNOUT //No brownout reset 
.................... #FUSES IESO //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES BORV40 //Brownout reset at 4.0V 
.................... #FUSES NOWRT //Program memory not write protected 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <oasysLCD.c> 
.................... //*-- 
.................... // This code is for PIC16F886 burning 
.................... // It is a slave on I2C communication (Go-go board is a master) 
.................... // This PIC16F886 must be socketed on the pink board (LCD controller) 
.................... // while the LCD module is on the top and the gogo board is under. 
.................... // 
.................... //  --- 5/2/11 Bug fix - Roger 
.................... //      * dirty character algorithm has been debugged. It now works well. 
.................... //      * showNumber int16 takes 300usec to complete, causing an overrun 
.................... //        error when the i2c master sends commands too quickly. The gogo 
.................... //        firmware has been updated to add a delay to make sure this does 
.................... //        not happen. 
.................... // 
.................... //  --- 4/24/11 Code restructuring - Roger 
.................... //      * scrren updates takes place only on dirty characters (changed since 
.................... //        the last screen update). 
.................... //      * Supports sensor update stream from the gogoboard. But this info 
.................... //        still cannot be shown on the screen. 
.................... //      * Code support for display-short-text (used on 7-segment displays) 
.................... //        but still does not work 
.................... //      * Code has been restructured  
.................... // 
.................... //  --- 4/15/11 Changed constant defs - Roger 
.................... //      Changed constants to make the display module compatible with 
.................... //      The I2C commands for the 7-segment module.  
.................... // 
.................... //  --- 3/24/11 Modified for the new LCD PCB v1.1 - Roger 
.................... //      * used defined declaration for pin assignment and i2c address instead of  
.................... //        hard-coded values. 
.................... //      * changed i2c address from 0xb2 to 0xb4 as defined in the i2c address allocation document 
.................... //      * changed EN,RW,RS pins on the PIC to match those used on the v 1.1 PCB 
....................  
.................... //  --- 3/10/11 Work Well and stable - PC 
.................... //       * handler I2C command HIDECUR, SHOWCUR, GETPOS, SETPOS, CLEAR, DISPLAY  
.................... //       * refresh is used to stop timer interupt after display whole text 
.................... // 
.................... //  --- 2/26/11 Modification - PC 
.................... //       * include to be the right IC (not 16F877A) 
.................... //       * the initial screen 
....................  
.................... //* 
....................  
.................... #define DEBUG_ON 0      // 1 = debug enabled -> will show error codes on the lcd screen 
....................  
....................  
.................... //#include <16F886.H> 
....................  
....................  
.................... #use fast_io(C) 
....................  
....................  
.................... #define I2C_ADDRESS  0xB4 
....................  
.................... #define PIN_EN PIN_C7   // Enable signal 
.................... #define PIN_RS PIN_C5   // register selection (H=data register, L=instruction register) 
.................... #define PIN_RW PIN_C6   // Read/Write selection (H=Read, L=Write) 
....................  
....................  
.................... #define T1_COUNTER 54000 
....................  
.................... //command 
.................... // The first 5 commands are compatible with both the 7-segment and lcd character displays 
.................... #define DISPLAY_CMD_PING  1 
.................... #define DISPLAY_VALUE 2 
.................... #define DISPLAY_SHORT_TEXT   3     // shows a 4 letter text. This is here to provide compatibility with the 7-segment display 
.................... #define DISPLAY_UPDATE_SENSORS 4 
.................... #define DISPLAY_LONG_TEXT 5 
....................  
.................... // These commands are specific to the LCD character display 
.................... #define CLEAR 6 
.................... #define GETPOS 7 
.................... #define SETPOS 8 
.................... #define HIDECUR 9 
.................... #define SHOWCUR 10 
....................  
.................... #define NOOP 99 
....................  
.................... //STAT 
.................... #define WAIT_ADDRESS 0 
.................... #define WAIT_CMD 1 
.................... #define WAIT_POSITION 2 
.................... #define WAIT_CHARACTOR 3 
.................... #define SEND_POSITION 4 
.................... #define WAIT_VALUE_HIGH_BYTE 5 
.................... #define WAIT_VALUE_LOW_BYTE 6 
.................... #define READY_FOR_SENSOR_HI      7 
.................... #define READY_FOR_SENSOR_LOW     8 
.................... #define WAIT_SHORT_TEXT1      9 
.................... #define WAIT_SHORT_TEXT2      10 
.................... #define WAIT_SHORT_TEXT3      11 
.................... #define WAIT_SHORT_TEXT4      12 
....................  
.................... // Error codes 
.................... #define ERR_UNKNOWN_COMMAND 0    // unknown I2C command 
.................... #define ERR_UNKNOWN_STATE 1      // unknown I2C state 
.................... #define ERR_WRONG_STATE 2        // wrong I2C idle state (i2c reset will tak place) 
....................  
.................... // I2C registers -> used to reset i2c 
.................... #bit SSPEN = 0x14.5 
.................... #bit SSPOV = 0x14.6 
.................... #bit WCOL  = 0x14.7 
....................  
.................... #fuses HS,NOWDT,NOPROTECT, BROWNOUT, PUT, NOMCLR 
.................... #use delay (clock=20000000) 
*
0656:  MOVLW  E0
0657:  MOVWF  04
0658:  BCF    03.7
0659:  MOVF   00,W
065A:  BTFSC  03.2
065B:  GOTO   669
065C:  MOVLW  06
065D:  MOVWF  78
065E:  CLRF   77
065F:  DECFSZ 77,F
0660:  GOTO   65F
0661:  DECFSZ 78,F
0662:  GOTO   65E
0663:  MOVLW  7B
0664:  MOVWF  77
0665:  DECFSZ 77,F
0666:  GOTO   665
0667:  DECFSZ 00,F
0668:  GOTO   65C
0669:  RETURN
*
0AAF:  MOVLW  03
0AB0:  SUBWF  55,F
0AB1:  BTFSS  03.0
0AB2:  GOTO   2BD
0AB3:  MOVLW  D5
0AB4:  MOVWF  04
0AB5:  BCF    03.7
0AB6:  MOVF   00,W
0AB7:  BTFSC  03.2
0AB8:  GOTO   2BD
0AB9:  GOTO   2BB
0ABA:  GOTO   2BB
0ABB:  DECFSZ 00,F
0ABC:  GOTO   2BA
....................  
.................... #include <stdlib.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1048:  BCF    03.6
1049:  CLRF   29
104A:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <MCP3208.c> 
....................  
.................... //#use rs232(baud=9600, xmit=PIN_C0,rcv=PIN_C1, FORCE_SW)  // debugging purposes 
....................  
....................  
.................... void resetI2C(); 
.................... void submit(); 
.................... void type(int code); 
.................... void fillBlankSensorsWithDefaultValue(void); 
.................... void triggerScreenUpdate(); 
.................... void clearScreen(); 
.................... void showCursor(); 
.................... void hideCursor(); 
.................... void twoDisplay(); 
.................... void setPosition(int pos); 
.................... int getPosition(); 
.................... void showError(int errCode, int data); 
.................... void init(); 
.................... void updateScreen(); 
.................... void main(); 
....................  
.................... //static int setCursor =0;  
.................... int inputCursor=0; //input cursor position  
.................... ///static int outputCursor = 1; // current cursur position 
....................  
....................  
....................  
.................... static int slaveState = WAIT_ADDRESS; // start state 
.................... int input = 0; 
.................... //int cmd = NOOP; 
.................... int gblDisplayBufferIndex=0;   
.................... int gblDisplayModuleCursorPos=0; 
.................... int1 gblTimeToUpdateScreen=0;  // flag to indicate when to update the screen 
....................  
.................... char curText[0x21]="                                "; 
104B:  MOVLW  20
104C:  MOVWF  35
104D:  MOVWF  36
104E:  MOVWF  37
104F:  MOVWF  38
1050:  MOVWF  39
1051:  MOVWF  3A
1052:  MOVWF  3B
1053:  MOVWF  3C
1054:  MOVWF  3D
1055:  MOVWF  3E
1056:  MOVWF  3F
1057:  MOVWF  40
1058:  MOVWF  41
1059:  MOVWF  42
105A:  MOVWF  43
105B:  MOVWF  44
105C:  MOVWF  45
105D:  MOVWF  46
105E:  MOVWF  47
105F:  MOVWF  48
1060:  MOVWF  49
1061:  MOVWF  4A
1062:  MOVWF  4B
1063:  MOVWF  4C
1064:  MOVWF  4D
1065:  MOVWF  4E
1066:  MOVWF  4F
1067:  MOVWF  50
1068:  MOVWF  51
1069:  MOVWF  52
106A:  MOVWF  53
106B:  MOVWF  54
106C:  CLRF   55
.................... int gblNewLCDPos =0; 
....................  
.................... int16 gblDisplayValue=0; 
.................... char valueBuffer[6]="     ";  // buffer to hold the text version of the received 16 bit display value 
106D:  MOVWF  59
106E:  MOVWF  5A
106F:  MOVWF  5B
1070:  MOVWF  5C
1071:  MOVWF  5D
1072:  CLRF   5E
....................  
.................... /// varialbes used to receive sensor values from the gogo board 
.................... int gblSensorBufferHi; 
.................... int gblSensorBufferLow; 
.................... int16 gblSensorValues[8]; 
....................  
.................... int gblSensorTimeout = 0; 
.................... int gblUpdatedSensors = 0;  // keeps log of which sensors values were received 
.................... int gblLastSensorReceived; // logs the latest sensor port number received 
....................  
.................... int32 gblDirtyBits = 0xffffffff;  // flags the characters that have changed 
....................  
.................... // variables used to tranform int16 into a string. 
.................... //!int tenThousands; 
.................... //!int thousands; 
.................... //!int hundreds; 
.................... //!int tens; 
.................... //!int ones; 
....................  
.................... char dis0;  // 1 
.................... char dis1;  // 10 
.................... char dis2;  // 100 
.................... char dis3;  // 1000 
.................... char dis4;  // 10000 
.................... //char dis5;  // 100000 
.................... char disf1; // 0.1 
.................... char disf2; // 0.01 
....................  
....................  
.................... // Timer1 triggers about every 4.6 ms. (20MHz DIV_BY_2 and timer = 54000) 
....................  
.................... #int_timer1      
.................... void timer1_isr(void) {   
....................     
....................    gblTimeToUpdateScreen = 1;  // signals main() to update the screen 
*
003A:  BSF    34.0
....................    set_timer1(T1_COUNTER); 
003B:  MOVLW  D2
003C:  MOVWF  0F
003D:  MOVLW  F0
003E:  MOVWF  0E
....................  
.................... } 
....................  
....................  
003F:  BCF    0C.0
0040:  BCF    0A.3
0041:  BCF    0A.4
0042:  GOTO   023
.................... void triggerScreenUpdate() { 
....................    // may need to set a flag so that we don't re-trigger while 
....................    // the previous update has not completed 
....................  
....................    gblDisplayBufferIndex=0; 
*
06EC:  CLRF   32
....................     
.................... //   gblNeedToUpdateScreen=1;  // this flag garantees that the  
....................    enable_interrupts(INT_TIMER1); 
06ED:  BSF    03.5
06EE:  BSF    0C.0
.................... } 
....................  
.................... void resetI2C() { 
....................          // clear the error flag registers and re-enable the i2c bus 
....................          SSPEN = 0;   // disable i2c 
*
0712:  BCF    14.5
....................          SSPOV = 0;   // clear the receive overflow flag 
0713:  BCF    14.6
....................          WCOL = 0;    // clear the write collision flag 
0714:  BCF    14.7
....................  
....................          SSPEN = 1;   // re-enable i2c 
0715:  BSF    14.5
....................  
.................... } 
....................  
.................... void submit(){ 
....................  
....................    output_high(PIN_EN); 
*
06AC:  BSF    07.7
....................    delay_us(50); 
06AD:  MOVLW  53
06AE:  MOVWF  77
06AF:  DECFSZ 77,F
06B0:  GOTO   6AF
....................    output_low(PIN_EN); 
06B1:  BCF    07.7
.................... } 
06B2:  RETURN
....................  
.................... void type(int text){ // convert a charactor to ascii 
....................  
....................    //show a char on LCD 
....................    output_high(PIN_RS); 
*
0719:  BSF    07.5
....................    if (text=='\0') { text = ' '; } 
071A:  BSF    03.5
071B:  MOVF   4E,F
071C:  BTFSS  03.2
071D:  GOTO   720
071E:  MOVLW  20
071F:  MOVWF  4E
....................    output_b(text); 
0720:  CLRF   06
0721:  MOVF   4E,W
0722:  BCF    03.5
0723:  MOVWF  06
....................    submit();    
0724:  CALL   6AC
....................    output_low(PIN_RS);  
0725:  BCF    07.5
....................    gblDisplayModuleCursorPos++;  // update var that tracks the display cursor pos 
0726:  INCF   33,F
....................     
....................    //position updating 
....................    ///outputCursor++; 
....................    ///if(outputCursor==32){  //the last position 
....................                            //this case happens when text is too long(>0x32) 
....................    ////setPosition(0); 
....................    ///outputCursor=0;      
....................    ///} 
....................   
.................... } 
0727:  RETURN
....................  
.................... // used when recieving sensor values from the gogoboard 
.................... void fillBlankSensorsWithDefaultValue(void) { 
....................    int i; 
....................     
....................    for (i=0;i<8;i++) { 
....................       // if the sensor value has not been updated 
....................       // then fill in the values with 1023 
....................       if (!bit_test(gblUpdatedSensors, i)) {    
....................          gblSensorValues[i]=1023;             
....................       } 
....................    } 
....................  
.................... } 
....................  
....................  
....................  
.................... void clearScreen() { 
....................   inputCursor=0; 
....................   strcpy(curText,"                                "); 
....................   gblDirtyBits=0xffffffff;  // set all 32 bits as dirty 
....................   triggerScreenUpdate(); 
.................... } 
....................  
.................... void showError(int errCode, int data) { 
....................    if (!DEBUG_ON)  return; 
....................     
....................    // todo: show error message on the screen 
....................    clearScreen(); 
....................    sprintf(curText, "Error #%u, %u", errCode, data); 
....................    gblDirtyBits=0xffffffff;  // set all 32 bits as dirty 
....................    triggerScreenUpdate(); 
.................... } 
....................  
.................... void showCursor(){ 
....................    output_low(PIN_RS); 
....................    output_b(0x0F); 
....................    submit(); 
.................... } 
....................  
.................... void hideCursor(){ 
....................    output_low(PIN_RS); 
*
06DB:  BCF    07.5
....................    output_b(0x0C); 
06DC:  BSF    03.5
06DD:  CLRF   06
06DE:  MOVLW  0C
06DF:  BCF    03.5
06E0:  MOVWF  06
....................    submit(); 
06E1:  CALL   6AC
.................... } 
....................  
....................  
.................... void setPosition(int pos){ 
....................    output_low(PIN_RS); 
*
06B3:  BCF    07.5
....................    output_b(0x80 + 0x40 * !!( pos & 0x10 ) + ( pos & 0x0F )); 
06B4:  MOVLW  00
06B5:  BSF    03.5
06B6:  BTFSC  4E.4
06B7:  MOVLW  01
06B8:  MOVWF  77
06B9:  SWAPF  77,F
06BA:  RLF    77,F
06BB:  RLF    77,F
06BC:  MOVLW  C0
06BD:  ANDWF  77,F
06BE:  MOVF   77,W
06BF:  ADDLW  80
06C0:  MOVWF  4F
06C1:  MOVF   4E,W
06C2:  ANDLW  0F
06C3:  ADDWF  4F,F
06C4:  CLRF   06
06C5:  MOVF   4F,W
06C6:  BCF    03.5
06C7:  MOVWF  06
....................    submit(); 
06C8:  CALL   6AC
....................    gblDisplayModuleCursorPos = pos;   // update variable that tracks the display cursor 
06C9:  BSF    03.5
06CA:  MOVF   4E,W
06CB:  BCF    03.5
06CC:  MOVWF  33
.................... } 
06CD:  RETURN
....................  
.................... int getPosition() { 
....................    return(gblDisplayModuleCursorPos); 
*
0765:  BCF    03.5
0766:  MOVF   33,W
0767:  MOVWF  78
.................... } 
....................  
.................... void twoDisplay(){ 
....................    output_b(0x38); 
*
06E2:  BSF    03.5
06E3:  CLRF   06
06E4:  MOVLW  38
06E5:  BCF    03.5
06E6:  MOVWF  06
....................    submit(); 
06E7:  CALL   6AC
.................... } 
....................  
.................... void init(){ 
....................    output_low(PIN_C2);   // debug pin 
*
06CE:  BCF    07.2
....................  
....................    delay_ms(100); 
06CF:  MOVLW  64
06D0:  BSF    03.5
06D1:  MOVWF  60
06D2:  BCF    03.5
06D3:  CALL   656
....................    output_b(0x00); 
06D4:  BSF    03.5
06D5:  CLRF   06
06D6:  BCF    03.5
06D7:  CLRF   06
....................    output_low(PIN_EN); 
06D8:  BCF    07.7
....................    output_low(PIN_RW); 
06D9:  BCF    07.6
....................    output_low(PIN_RS); 
06DA:  BCF    07.5
....................    hideCursor(); 
....................    twoDisplay(); 
....................  
....................    //type('S');type('t');type('a');type('r');type('t');type('i');type('n');type('g');type('.');type('.');type('.'); 
....................    //delay_ms(1500); 
....................  
....................  
....................    setPosition(0); 
*
06E8:  BSF    03.5
06E9:  CLRF   4E
06EA:  BCF    03.5
06EB:  CALL   6B3
....................    triggerScreenUpdate(); 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
*
06EF:  BSF    03.6
06F0:  MOVF   09,W
06F1:  ANDLW  C0
06F2:  MOVWF  09
06F3:  BCF    03.6
06F4:  BCF    1F.4
06F5:  BCF    1F.5
06F6:  MOVLW  00
06F7:  BSF    03.6
06F8:  MOVWF  08
....................    setup_adc(ADC_OFF); 
06F9:  BCF    03.5
06FA:  BCF    03.6
06FB:  BCF    1F.0
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_256); 
06FC:  MOVLW  08
06FD:  BSF    03.6
06FE:  MOVWF  05
06FF:  BSF    03.5
0700:  BCF    03.6
0701:  MOVF   01,W
0702:  ANDLW  C0
0703:  IORLW  07
0704:  MOVWF  01
0705:  CLRWDT
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
0706:  MOVLW  05
0707:  BCF    03.5
0708:  MOVWF  10
....................  
....................    set_timer1(T1_COUNTER); 
0709:  MOVLW  D2
070A:  MOVWF  0F
070B:  MOVLW  F0
070C:  MOVWF  0E
....................  
....................     
....................    enable_interrupts(INT_SSP); 
070D:  BSF    03.5
070E:  BSF    0C.3
....................    enable_interrupts(GLOBAL);    
070F:  MOVLW  C0
0710:  BCF    03.5
0711:  IORWF  0B,F
....................  
....................    resetI2C();    // clear the i2c circuity 
....................  
....................  
.................... } 
*
0716:  BCF    0A.3
0717:  BSF    0A.4
0718:  GOTO   089 (RETURN)
....................  
....................  
.................... // update 1 character on the screen.  
....................  
.................... void updateScreen() { 
....................  
....................     
....................    if(gblDisplayBufferIndex==32){  // we have updated all the characters 
*
0728:  MOVF   32,W
0729:  SUBLW  20
072A:  BTFSS  03.2
072B:  GOTO   730
....................       disable_interrupts(INT_TIMER1); 
072C:  BSF    03.5
072D:  BCF    0C.0
....................    } 
....................    else { 
072E:  GOTO   788
072F:  BCF    03.5
....................  
....................       // if current char has changed -> display it 
....................       if (bit_test(gblDirtyBits, gblDisplayBufferIndex)) { 
0730:  MOVF   7E,W
0731:  MOVWF  7A
0732:  MOVF   7D,W
0733:  MOVWF  79
0734:  MOVF   7C,W
0735:  MOVWF  78
0736:  MOVF   7B,W
0737:  MOVWF  77
0738:  MOVF   32,W
0739:  BSF    03.5
073A:  MOVWF  45
073B:  BTFSC  03.2
073C:  GOTO   744
073D:  BCF    03.0
073E:  RRF    7A,F
073F:  RRF    79,F
0740:  RRF    78,F
0741:  RRF    77,F
0742:  DECFSZ 45,F
0743:  GOTO   73D
0744:  BTFSS  77.0
0745:  GOTO   785
....................          bit_clear(gblDirtyBits, gblDisplayBufferIndex); 
0746:  CLRF   7A
0747:  CLRF   79
0748:  CLRF   78
0749:  MOVLW  01
074A:  MOVWF  77
074B:  BCF    03.5
074C:  MOVF   32,W
074D:  BSF    03.5
074E:  MOVWF  45
074F:  BTFSC  03.2
0750:  GOTO   758
0751:  BCF    03.0
0752:  RLF    77,F
0753:  RLF    78,F
0754:  RLF    79,F
0755:  RLF    7A,F
0756:  DECFSZ 45,F
0757:  GOTO   751
0758:  MOVLW  FF
0759:  XORWF  77,F
075A:  XORWF  78,F
075B:  XORWF  79,F
075C:  XORWF  7A,F
075D:  MOVF   77,W
075E:  ANDWF  7B,F
075F:  MOVF   78,W
0760:  ANDWF  7C,F
0761:  MOVF   79,W
0762:  ANDWF  7D,F
0763:  MOVF   7A,W
0764:  ANDWF  7E,F
....................           
....................          // if the display's screen cursor does not match the buffer index 
....................          // then we have to update the cursor position. 
....................          if (gblDisplayBufferIndex != getPosition()) { 
*
0768:  MOVF   78,W
0769:  SUBWF  32,W
076A:  BTFSC  03.2
076B:  GOTO   771
....................             setPosition(gblDisplayBufferIndex); 
076C:  MOVF   32,W
076D:  BSF    03.5
076E:  MOVWF  4E
076F:  BCF    03.5
0770:  CALL   6B3
....................          } 
....................  
....................          if(gblDisplayBufferIndex==16){  // If at second line -> we must manually set the position 
0771:  MOVF   32,W
0772:  SUBLW  10
0773:  BTFSS  03.2
0774:  GOTO   77A
....................            setPosition(16); 
0775:  MOVLW  10
0776:  BSF    03.5
0777:  MOVWF  4E
0778:  BCF    03.5
0779:  CALL   6B3
....................          } 
....................  
....................          type(curText[gblDisplayBufferIndex]); 
077A:  MOVLW  35
077B:  ADDWF  32,W
077C:  MOVWF  04
077D:  BCF    03.7
077E:  MOVF   00,W
077F:  BSF    03.5
0780:  MOVWF  45
0781:  MOVWF  4E
0782:  BCF    03.5
0783:  CALL   719
0784:  BSF    03.5
....................       }  
....................       gblDisplayBufferIndex++; 
0785:  BCF    03.5
0786:  INCF   32,F
0787:  BSF    03.5
....................    } 
.................... } 
0788:  BCF    03.5
0789:  BCF    0A.3
078A:  BSF    0A.4
078B:  GOTO   098 (RETURN)
....................  
.................... void show_temp(int16 temp){ 
.................... //!   if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!         } 
....................    setPosition(0); 
*
08A4:  BSF    03.5
08A5:  CLRF   4E
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   6B3
08A9:  BSF    0A.3
....................    dis0 =  ((temp/1000)+48); 
08AA:  BSF    03.5
08AB:  MOVF   48,W
08AC:  MOVWF  51
08AD:  MOVF   47,W
08AE:  MOVWF  50
08AF:  MOVLW  03
08B0:  MOVWF  53
08B1:  MOVLW  E8
08B2:  MOVWF  52
08B3:  BCF    03.5
08B4:  CALL   07D
08B5:  MOVF   79,W
08B6:  BSF    03.5
08B7:  MOVWF  4A
08B8:  MOVF   78,W
08B9:  MOVWF  49
08BA:  MOVLW  30
08BB:  ADDWF  49,W
08BC:  MOVWF  74
....................    dis1 =  (((temp%1000)/100)+48); 
08BD:  MOVF   48,W
08BE:  MOVWF  51
08BF:  MOVF   47,W
08C0:  MOVWF  50
08C1:  MOVLW  03
08C2:  MOVWF  53
08C3:  MOVLW  E8
08C4:  MOVWF  52
08C5:  BCF    03.5
08C6:  CALL   07D
08C7:  MOVF   77,W
08C8:  BSF    03.5
08C9:  MOVWF  49
08CA:  MOVF   7A,W
08CB:  MOVWF  4A
08CC:  MOVWF  51
08CD:  MOVF   49,W
08CE:  MOVWF  50
08CF:  CLRF   53
08D0:  MOVLW  64
08D1:  MOVWF  52
08D2:  BCF    03.5
08D3:  CALL   07D
08D4:  MOVF   79,W
08D5:  BSF    03.5
08D6:  MOVWF  4A
08D7:  MOVF   78,W
08D8:  MOVWF  49
08D9:  MOVLW  30
08DA:  ADDWF  49,W
08DB:  MOVWF  75
....................    disf1 = ((((temp%1000)%100)/10)+48); 
08DC:  MOVF   48,W
08DD:  MOVWF  51
08DE:  MOVF   47,W
08DF:  MOVWF  50
08E0:  MOVLW  03
08E1:  MOVWF  53
08E2:  MOVLW  E8
08E3:  MOVWF  52
08E4:  BCF    03.5
08E5:  CALL   07D
08E6:  MOVF   77,W
08E7:  BSF    03.5
08E8:  MOVWF  49
08E9:  MOVF   7A,W
08EA:  MOVWF  4A
08EB:  MOVWF  51
08EC:  MOVF   49,W
08ED:  MOVWF  50
08EE:  CLRF   53
08EF:  MOVLW  64
08F0:  MOVWF  52
08F1:  BCF    03.5
08F2:  CALL   07D
08F3:  MOVF   77,W
08F4:  BSF    03.5
08F5:  MOVWF  49
08F6:  MOVF   7A,W
08F7:  MOVWF  4A
08F8:  MOVWF  51
08F9:  MOVF   49,W
08FA:  MOVWF  50
08FB:  CLRF   53
08FC:  MOVLW  0A
08FD:  MOVWF  52
08FE:  BCF    03.5
08FF:  CALL   07D
0900:  MOVF   79,W
0901:  BSF    03.5
0902:  MOVWF  4A
0903:  MOVF   78,W
0904:  MOVWF  49
0905:  MOVLW  30
0906:  ADDWF  49,W
0907:  MOVWF  22
....................    disf2 = ((((temp%1000)%100)%10)+48); 
0908:  MOVF   48,W
0909:  MOVWF  51
090A:  MOVF   47,W
090B:  MOVWF  50
090C:  MOVLW  03
090D:  MOVWF  53
090E:  MOVLW  E8
090F:  MOVWF  52
0910:  BCF    03.5
0911:  CALL   07D
0912:  MOVF   77,W
0913:  BSF    03.5
0914:  MOVWF  49
0915:  MOVF   7A,W
0916:  MOVWF  4A
0917:  MOVWF  51
0918:  MOVF   49,W
0919:  MOVWF  50
091A:  CLRF   53
091B:  MOVLW  64
091C:  MOVWF  52
091D:  BCF    03.5
091E:  CALL   07D
091F:  MOVF   77,W
0920:  BSF    03.5
0921:  MOVWF  49
0922:  MOVF   7A,W
0923:  MOVWF  4A
0924:  MOVWF  51
0925:  MOVF   49,W
0926:  MOVWF  50
0927:  CLRF   53
0928:  MOVLW  0A
0929:  MOVWF  52
092A:  BCF    03.5
092B:  CALL   07D
092C:  MOVF   77,W
092D:  BSF    03.5
092E:  MOVWF  49
092F:  MOVF   7A,W
0930:  MOVWF  4A
0931:  MOVLW  30
0932:  ADDWF  49,W
0933:  MOVWF  23
....................    type('T');type('e');type('m');type('p');type(':'); 
0934:  MOVLW  54
0935:  MOVWF  4E
0936:  BCF    0A.3
0937:  BCF    03.5
0938:  CALL   719
0939:  BSF    0A.3
093A:  MOVLW  65
093B:  BSF    03.5
093C:  MOVWF  4E
093D:  BCF    0A.3
093E:  BCF    03.5
093F:  CALL   719
0940:  BSF    0A.3
0941:  MOVLW  6D
0942:  BSF    03.5
0943:  MOVWF  4E
0944:  BCF    0A.3
0945:  BCF    03.5
0946:  CALL   719
0947:  BSF    0A.3
0948:  MOVLW  70
0949:  BSF    03.5
094A:  MOVWF  4E
094B:  BCF    0A.3
094C:  BCF    03.5
094D:  CALL   719
094E:  BSF    0A.3
094F:  MOVLW  3A
0950:  BSF    03.5
0951:  MOVWF  4E
0952:  BCF    0A.3
0953:  BCF    03.5
0954:  CALL   719
0955:  BSF    0A.3
....................    type(dis0);type(dis1);type('.');type(disf1);type(disf2);type('\0');type('C'); 
0956:  MOVF   74,W
0957:  BSF    03.5
0958:  MOVWF  4E
0959:  BCF    0A.3
095A:  BCF    03.5
095B:  CALL   719
095C:  BSF    0A.3
095D:  MOVF   75,W
095E:  BSF    03.5
095F:  MOVWF  4E
0960:  BCF    0A.3
0961:  BCF    03.5
0962:  CALL   719
0963:  BSF    0A.3
0964:  MOVLW  2E
0965:  BSF    03.5
0966:  MOVWF  4E
0967:  BCF    0A.3
0968:  BCF    03.5
0969:  CALL   719
096A:  BSF    0A.3
096B:  BSF    03.5
096C:  MOVF   22,W
096D:  MOVWF  4E
096E:  BCF    0A.3
096F:  BCF    03.5
0970:  CALL   719
0971:  BSF    0A.3
0972:  BSF    03.5
0973:  MOVF   23,W
0974:  MOVWF  4E
0975:  BCF    0A.3
0976:  BCF    03.5
0977:  CALL   719
0978:  BSF    0A.3
0979:  BSF    03.5
097A:  CLRF   4E
097B:  BCF    0A.3
097C:  BCF    03.5
097D:  CALL   719
097E:  BSF    0A.3
097F:  MOVLW  43
0980:  BSF    03.5
0981:  MOVWF  4E
0982:  BCF    0A.3
0983:  BCF    03.5
0984:  CALL   719
0985:  BSF    0A.3
....................     
.................... } 
0986:  BCF    0A.3
0987:  BSF    0A.4
0988:  GOTO   365 (RETURN)
....................  
.................... void show_humid(int16 humid){ 
.................... //!   if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!         } 
....................    setPosition(16); 
0989:  MOVLW  10
098A:  BSF    03.5
098B:  MOVWF  4E
098C:  BCF    0A.3
098D:  BCF    03.5
098E:  CALL   6B3
098F:  BSF    0A.3
....................    dis0 =  ((humid/1000)+48); 
0990:  BSF    03.5
0991:  MOVF   48,W
0992:  MOVWF  51
0993:  MOVF   47,W
0994:  MOVWF  50
0995:  MOVLW  03
0996:  MOVWF  53
0997:  MOVLW  E8
0998:  MOVWF  52
0999:  BCF    03.5
099A:  CALL   07D
099B:  MOVF   79,W
099C:  BSF    03.5
099D:  MOVWF  4A
099E:  MOVF   78,W
099F:  MOVWF  49
09A0:  MOVLW  30
09A1:  ADDWF  49,W
09A2:  MOVWF  74
....................    dis1 =  (((humid%1000)/100)+48); 
09A3:  MOVF   48,W
09A4:  MOVWF  51
09A5:  MOVF   47,W
09A6:  MOVWF  50
09A7:  MOVLW  03
09A8:  MOVWF  53
09A9:  MOVLW  E8
09AA:  MOVWF  52
09AB:  BCF    03.5
09AC:  CALL   07D
09AD:  MOVF   77,W
09AE:  BSF    03.5
09AF:  MOVWF  49
09B0:  MOVF   7A,W
09B1:  MOVWF  4A
09B2:  MOVWF  51
09B3:  MOVF   49,W
09B4:  MOVWF  50
09B5:  CLRF   53
09B6:  MOVLW  64
09B7:  MOVWF  52
09B8:  BCF    03.5
09B9:  CALL   07D
09BA:  MOVF   79,W
09BB:  BSF    03.5
09BC:  MOVWF  4A
09BD:  MOVF   78,W
09BE:  MOVWF  49
09BF:  MOVLW  30
09C0:  ADDWF  49,W
09C1:  MOVWF  75
....................    disf1 = ((((humid%1000)%100)/10)+48); 
09C2:  MOVF   48,W
09C3:  MOVWF  51
09C4:  MOVF   47,W
09C5:  MOVWF  50
09C6:  MOVLW  03
09C7:  MOVWF  53
09C8:  MOVLW  E8
09C9:  MOVWF  52
09CA:  BCF    03.5
09CB:  CALL   07D
09CC:  MOVF   77,W
09CD:  BSF    03.5
09CE:  MOVWF  49
09CF:  MOVF   7A,W
09D0:  MOVWF  4A
09D1:  MOVWF  51
09D2:  MOVF   49,W
09D3:  MOVWF  50
09D4:  CLRF   53
09D5:  MOVLW  64
09D6:  MOVWF  52
09D7:  BCF    03.5
09D8:  CALL   07D
09D9:  MOVF   77,W
09DA:  BSF    03.5
09DB:  MOVWF  49
09DC:  MOVF   7A,W
09DD:  MOVWF  4A
09DE:  MOVWF  51
09DF:  MOVF   49,W
09E0:  MOVWF  50
09E1:  CLRF   53
09E2:  MOVLW  0A
09E3:  MOVWF  52
09E4:  BCF    03.5
09E5:  CALL   07D
09E6:  MOVF   79,W
09E7:  BSF    03.5
09E8:  MOVWF  4A
09E9:  MOVF   78,W
09EA:  MOVWF  49
09EB:  MOVLW  30
09EC:  ADDWF  49,W
09ED:  MOVWF  22
....................    disf2 = ((((humid%1000)%100)%10)+48); 
09EE:  MOVF   48,W
09EF:  MOVWF  51
09F0:  MOVF   47,W
09F1:  MOVWF  50
09F2:  MOVLW  03
09F3:  MOVWF  53
09F4:  MOVLW  E8
09F5:  MOVWF  52
09F6:  BCF    03.5
09F7:  CALL   07D
09F8:  MOVF   77,W
09F9:  BSF    03.5
09FA:  MOVWF  49
09FB:  MOVF   7A,W
09FC:  MOVWF  4A
09FD:  MOVWF  51
09FE:  MOVF   49,W
09FF:  MOVWF  50
0A00:  CLRF   53
0A01:  MOVLW  64
0A02:  MOVWF  52
0A03:  BCF    03.5
0A04:  CALL   07D
0A05:  MOVF   77,W
0A06:  BSF    03.5
0A07:  MOVWF  49
0A08:  MOVF   7A,W
0A09:  MOVWF  4A
0A0A:  MOVWF  51
0A0B:  MOVF   49,W
0A0C:  MOVWF  50
0A0D:  CLRF   53
0A0E:  MOVLW  0A
0A0F:  MOVWF  52
0A10:  BCF    03.5
0A11:  CALL   07D
0A12:  MOVF   77,W
0A13:  BSF    03.5
0A14:  MOVWF  49
0A15:  MOVF   7A,W
0A16:  MOVWF  4A
0A17:  MOVLW  30
0A18:  ADDWF  49,W
0A19:  MOVWF  23
....................    type('H');type('u');type('m');type('i');type('d');type(':'); 
0A1A:  MOVLW  48
0A1B:  MOVWF  4E
0A1C:  BCF    0A.3
0A1D:  BCF    03.5
0A1E:  CALL   719
0A1F:  BSF    0A.3
0A20:  MOVLW  75
0A21:  BSF    03.5
0A22:  MOVWF  4E
0A23:  BCF    0A.3
0A24:  BCF    03.5
0A25:  CALL   719
0A26:  BSF    0A.3
0A27:  MOVLW  6D
0A28:  BSF    03.5
0A29:  MOVWF  4E
0A2A:  BCF    0A.3
0A2B:  BCF    03.5
0A2C:  CALL   719
0A2D:  BSF    0A.3
0A2E:  MOVLW  69
0A2F:  BSF    03.5
0A30:  MOVWF  4E
0A31:  BCF    0A.3
0A32:  BCF    03.5
0A33:  CALL   719
0A34:  BSF    0A.3
0A35:  MOVLW  64
0A36:  BSF    03.5
0A37:  MOVWF  4E
0A38:  BCF    0A.3
0A39:  BCF    03.5
0A3A:  CALL   719
0A3B:  BSF    0A.3
0A3C:  MOVLW  3A
0A3D:  BSF    03.5
0A3E:  MOVWF  4E
0A3F:  BCF    0A.3
0A40:  BCF    03.5
0A41:  CALL   719
0A42:  BSF    0A.3
....................    type(dis0);type(dis1);type('.');type(disf1);type(disf2);type('\0');type('%'); 
0A43:  MOVF   74,W
0A44:  BSF    03.5
0A45:  MOVWF  4E
0A46:  BCF    0A.3
0A47:  BCF    03.5
0A48:  CALL   719
0A49:  BSF    0A.3
0A4A:  MOVF   75,W
0A4B:  BSF    03.5
0A4C:  MOVWF  4E
0A4D:  BCF    0A.3
0A4E:  BCF    03.5
0A4F:  CALL   719
0A50:  BSF    0A.3
0A51:  MOVLW  2E
0A52:  BSF    03.5
0A53:  MOVWF  4E
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   719
0A57:  BSF    0A.3
0A58:  BSF    03.5
0A59:  MOVF   22,W
0A5A:  MOVWF  4E
0A5B:  BCF    0A.3
0A5C:  BCF    03.5
0A5D:  CALL   719
0A5E:  BSF    0A.3
0A5F:  BSF    03.5
0A60:  MOVF   23,W
0A61:  MOVWF  4E
0A62:  BCF    0A.3
0A63:  BCF    03.5
0A64:  CALL   719
0A65:  BSF    0A.3
0A66:  BSF    03.5
0A67:  CLRF   4E
0A68:  BCF    0A.3
0A69:  BCF    03.5
0A6A:  CALL   719
0A6B:  BSF    0A.3
0A6C:  MOVLW  25
0A6D:  BSF    03.5
0A6E:  MOVWF  4E
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  CALL   719
0A72:  BSF    0A.3
....................     
.................... } 
0A73:  BCF    0A.3
0A74:  BSF    0A.4
0A75:  GOTO   383 (RETURN)
....................  
.................... void show_water(int16 water){ 
....................       water=water/16; 
.................... //!      if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!         } 
....................       setPosition(15);type('\0'); 
....................    
....................       type('W'); type('a'); type('t'); type('e'); type('r'); type(':'); 
....................  
....................       char dis0=(water/10000)+48; 
....................       char dis1=((water%10000)/1000)+48; 
....................       char dis2=(((water%10000)%1000)/100)+48; 
....................       char dis3=((((water%10000)%1000)%100)/10)+48; 
....................       char dis4=((((water%10000)%1000)%100)%10)+48; 
....................        
....................       dis0 = dis0 == '0' ? '\0' : dis0; 
....................       type(dis0); type(dis1); type(dis2); type(dis3); type(dis4); type('\0'); type('c'); type('m'); 
.................... } 
....................  
.................... void show_sonic(int16 sonic){ 
....................       sonic=sonic/16; 
*
0BFD:  BSF    03.5
0BFE:  RRF    48,F
0BFF:  RRF    47,F
0C00:  RRF    48,F
0C01:  RRF    47,F
0C02:  RRF    48,F
0C03:  RRF    47,F
0C04:  RRF    48,F
0C05:  RRF    47,F
0C06:  MOVLW  0F
0C07:  ANDWF  48,F
.................... //!      if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!         } 
....................       sonic=600-sonic; 
0C08:  MOVF   47,W
0C09:  SUBLW  58
0C0A:  MOVWF  47
0C0B:  MOVF   48,W
0C0C:  BTFSS  03.0
0C0D:  INCFSZ 48,W
0C0E:  GOTO   411
0C0F:  MOVLW  02
0C10:  GOTO   412
0C11:  SUBLW  02
0C12:  MOVWF  48
....................       setPosition(15);type('\0'); 
0C13:  MOVLW  0F
0C14:  MOVWF  4E
0C15:  BCF    0A.3
0C16:  BCF    03.5
0C17:  CALL   6B3
0C18:  BSF    0A.3
0C19:  BSF    03.5
0C1A:  CLRF   4E
0C1B:  BCF    0A.3
0C1C:  BCF    03.5
0C1D:  CALL   719
0C1E:  BSF    0A.3
....................    
....................       type('W'); type('a'); type('t'); type('e'); type('r'); type(':'); 
0C1F:  MOVLW  57
0C20:  BSF    03.5
0C21:  MOVWF  4E
0C22:  BCF    0A.3
0C23:  BCF    03.5
0C24:  CALL   719
0C25:  BSF    0A.3
0C26:  MOVLW  61
0C27:  BSF    03.5
0C28:  MOVWF  4E
0C29:  BCF    0A.3
0C2A:  BCF    03.5
0C2B:  CALL   719
0C2C:  BSF    0A.3
0C2D:  MOVLW  74
0C2E:  BSF    03.5
0C2F:  MOVWF  4E
0C30:  BCF    0A.3
0C31:  BCF    03.5
0C32:  CALL   719
0C33:  BSF    0A.3
0C34:  MOVLW  65
0C35:  BSF    03.5
0C36:  MOVWF  4E
0C37:  BCF    0A.3
0C38:  BCF    03.5
0C39:  CALL   719
0C3A:  BSF    0A.3
0C3B:  MOVLW  72
0C3C:  BSF    03.5
0C3D:  MOVWF  4E
0C3E:  BCF    0A.3
0C3F:  BCF    03.5
0C40:  CALL   719
0C41:  BSF    0A.3
0C42:  MOVLW  3A
0C43:  BSF    03.5
0C44:  MOVWF  4E
0C45:  BCF    0A.3
0C46:  BCF    03.5
0C47:  CALL   719
0C48:  BSF    0A.3
....................  
....................       char dis0=(sonic/10000)+48; 
....................       char dis1=((sonic%10000)/1000)+48; 
....................       char dis2=(((sonic%10000)%1000)/100)+48; 
....................       char dis3=((((sonic%10000)%1000)%100)/10)+48; 
....................       char dis4=((((sonic%10000)%1000)%100)%10)+48; 
0C49:  BSF    03.5
0C4A:  MOVF   48,W
0C4B:  MOVWF  51
0C4C:  MOVF   47,W
0C4D:  MOVWF  50
0C4E:  MOVLW  27
0C4F:  MOVWF  53
0C50:  MOVLW  10
0C51:  MOVWF  52
0C52:  BCF    03.5
0C53:  CALL   07D
0C54:  MOVF   79,W
0C55:  BSF    03.5
0C56:  MOVWF  4F
0C57:  MOVF   78,W
0C58:  MOVWF  4E
0C59:  MOVLW  30
0C5A:  ADDWF  4E,W
0C5B:  MOVWF  49
0C5C:  MOVF   48,W
0C5D:  MOVWF  51
0C5E:  MOVF   47,W
0C5F:  MOVWF  50
0C60:  MOVLW  27
0C61:  MOVWF  53
0C62:  MOVLW  10
0C63:  MOVWF  52
0C64:  BCF    03.5
0C65:  CALL   07D
0C66:  MOVF   77,W
0C67:  BSF    03.5
0C68:  MOVWF  4E
0C69:  MOVF   7A,W
0C6A:  MOVWF  4F
0C6B:  MOVWF  51
0C6C:  MOVF   4E,W
0C6D:  MOVWF  50
0C6E:  MOVLW  03
0C6F:  MOVWF  53
0C70:  MOVLW  E8
0C71:  MOVWF  52
0C72:  BCF    03.5
0C73:  CALL   07D
0C74:  MOVF   79,W
0C75:  BSF    03.5
0C76:  MOVWF  4F
0C77:  MOVF   78,W
0C78:  MOVWF  4E
0C79:  MOVLW  30
0C7A:  ADDWF  4E,W
0C7B:  MOVWF  4A
0C7C:  MOVF   48,W
0C7D:  MOVWF  51
0C7E:  MOVF   47,W
0C7F:  MOVWF  50
0C80:  MOVLW  27
0C81:  MOVWF  53
0C82:  MOVLW  10
0C83:  MOVWF  52
0C84:  BCF    03.5
0C85:  CALL   07D
0C86:  MOVF   77,W
0C87:  BSF    03.5
0C88:  MOVWF  4E
0C89:  MOVF   7A,W
0C8A:  MOVWF  4F
0C8B:  MOVWF  51
0C8C:  MOVF   4E,W
0C8D:  MOVWF  50
0C8E:  MOVLW  03
0C8F:  MOVWF  53
0C90:  MOVLW  E8
0C91:  MOVWF  52
0C92:  BCF    03.5
0C93:  CALL   07D
0C94:  MOVF   77,W
0C95:  BSF    03.5
0C96:  MOVWF  4E
0C97:  MOVF   7A,W
0C98:  MOVWF  4F
0C99:  MOVWF  51
0C9A:  MOVF   4E,W
0C9B:  MOVWF  50
0C9C:  CLRF   53
0C9D:  MOVLW  64
0C9E:  MOVWF  52
0C9F:  BCF    03.5
0CA0:  CALL   07D
0CA1:  MOVF   79,W
0CA2:  BSF    03.5
0CA3:  MOVWF  4F
0CA4:  MOVF   78,W
0CA5:  MOVWF  4E
0CA6:  MOVLW  30
0CA7:  ADDWF  4E,W
0CA8:  MOVWF  4B
0CA9:  MOVF   48,W
0CAA:  MOVWF  51
0CAB:  MOVF   47,W
0CAC:  MOVWF  50
0CAD:  MOVLW  27
0CAE:  MOVWF  53
0CAF:  MOVLW  10
0CB0:  MOVWF  52
0CB1:  BCF    03.5
0CB2:  CALL   07D
0CB3:  MOVF   77,W
0CB4:  BSF    03.5
0CB5:  MOVWF  4E
0CB6:  MOVF   7A,W
0CB7:  MOVWF  4F
0CB8:  MOVWF  51
0CB9:  MOVF   4E,W
0CBA:  MOVWF  50
0CBB:  MOVLW  03
0CBC:  MOVWF  53
0CBD:  MOVLW  E8
0CBE:  MOVWF  52
0CBF:  BCF    03.5
0CC0:  CALL   07D
0CC1:  MOVF   77,W
0CC2:  BSF    03.5
0CC3:  MOVWF  4E
0CC4:  MOVF   7A,W
0CC5:  MOVWF  4F
0CC6:  MOVWF  51
0CC7:  MOVF   4E,W
0CC8:  MOVWF  50
0CC9:  CLRF   53
0CCA:  MOVLW  64
0CCB:  MOVWF  52
0CCC:  BCF    03.5
0CCD:  CALL   07D
0CCE:  MOVF   77,W
0CCF:  BSF    03.5
0CD0:  MOVWF  4E
0CD1:  MOVF   7A,W
0CD2:  MOVWF  4F
0CD3:  MOVWF  51
0CD4:  MOVF   4E,W
0CD5:  MOVWF  50
0CD6:  CLRF   53
0CD7:  MOVLW  0A
0CD8:  MOVWF  52
0CD9:  BCF    03.5
0CDA:  CALL   07D
0CDB:  MOVF   79,W
0CDC:  BSF    03.5
0CDD:  MOVWF  4F
0CDE:  MOVF   78,W
0CDF:  MOVWF  4E
0CE0:  MOVLW  30
0CE1:  ADDWF  4E,W
0CE2:  MOVWF  4C
0CE3:  MOVF   48,W
0CE4:  MOVWF  51
0CE5:  MOVF   47,W
0CE6:  MOVWF  50
0CE7:  MOVLW  27
0CE8:  MOVWF  53
0CE9:  MOVLW  10
0CEA:  MOVWF  52
0CEB:  BCF    03.5
0CEC:  CALL   07D
0CED:  MOVF   77,W
0CEE:  BSF    03.5
0CEF:  MOVWF  4E
0CF0:  MOVF   7A,W
0CF1:  MOVWF  4F
0CF2:  MOVWF  51
0CF3:  MOVF   4E,W
0CF4:  MOVWF  50
0CF5:  MOVLW  03
0CF6:  MOVWF  53
0CF7:  MOVLW  E8
0CF8:  MOVWF  52
0CF9:  BCF    03.5
0CFA:  CALL   07D
0CFB:  MOVF   77,W
0CFC:  BSF    03.5
0CFD:  MOVWF  4E
0CFE:  MOVF   7A,W
0CFF:  MOVWF  4F
0D00:  MOVWF  51
0D01:  MOVF   4E,W
0D02:  MOVWF  50
0D03:  CLRF   53
0D04:  MOVLW  64
0D05:  MOVWF  52
0D06:  BCF    03.5
0D07:  CALL   07D
0D08:  MOVF   77,W
0D09:  BSF    03.5
0D0A:  MOVWF  4E
0D0B:  MOVF   7A,W
0D0C:  MOVWF  4F
0D0D:  MOVWF  51
0D0E:  MOVF   4E,W
0D0F:  MOVWF  50
0D10:  CLRF   53
0D11:  MOVLW  0A
0D12:  MOVWF  52
0D13:  BCF    03.5
0D14:  CALL   07D
0D15:  MOVF   77,W
0D16:  BSF    03.5
0D17:  MOVWF  4E
0D18:  MOVF   7A,W
0D19:  MOVWF  4F
0D1A:  MOVLW  30
0D1B:  ADDWF  4E,W
0D1C:  MOVWF  4D
....................        
....................       dis0 = dis0 == '0' ? '\0' : dis0; 
0D1D:  MOVF   49,W
0D1E:  SUBLW  30
0D1F:  BTFSS  03.2
0D20:  GOTO   523
0D21:  MOVLW  00
0D22:  GOTO   524
0D23:  MOVF   49,W
0D24:  MOVWF  49
....................       type(dis0); type(dis1); type(dis2); type(dis3); type(dis4); type('\0'); type('c'); type('m'); 
0D25:  MOVF   49,W
0D26:  MOVWF  4E
0D27:  BCF    0A.3
0D28:  BCF    03.5
0D29:  CALL   719
0D2A:  BSF    0A.3
0D2B:  BSF    03.5
0D2C:  MOVF   4A,W
0D2D:  MOVWF  4E
0D2E:  BCF    0A.3
0D2F:  BCF    03.5
0D30:  CALL   719
0D31:  BSF    0A.3
0D32:  BSF    03.5
0D33:  MOVF   4B,W
0D34:  MOVWF  4E
0D35:  BCF    0A.3
0D36:  BCF    03.5
0D37:  CALL   719
0D38:  BSF    0A.3
0D39:  BSF    03.5
0D3A:  MOVF   4C,W
0D3B:  MOVWF  4E
0D3C:  BCF    0A.3
0D3D:  BCF    03.5
0D3E:  CALL   719
0D3F:  BSF    0A.3
0D40:  BSF    03.5
0D41:  MOVF   4D,W
0D42:  MOVWF  4E
0D43:  BCF    0A.3
0D44:  BCF    03.5
0D45:  CALL   719
0D46:  BSF    0A.3
0D47:  BSF    03.5
0D48:  CLRF   4E
0D49:  BCF    0A.3
0D4A:  BCF    03.5
0D4B:  CALL   719
0D4C:  BSF    0A.3
0D4D:  MOVLW  63
0D4E:  BSF    03.5
0D4F:  MOVWF  4E
0D50:  BCF    0A.3
0D51:  BCF    03.5
0D52:  CALL   719
0D53:  BSF    0A.3
0D54:  MOVLW  6D
0D55:  BSF    03.5
0D56:  MOVWF  4E
0D57:  BCF    0A.3
0D58:  BCF    03.5
0D59:  CALL   719
0D5A:  BSF    0A.3
.................... } 
0D5B:  BCF    0A.3
0D5C:  BSF    0A.4
0D5D:  GOTO   3AE (RETURN)
....................  
....................  
.................... void show_counter(int count){ 
....................       setPosition(31); 
....................       type('\0'); 
....................     
....................       type('C');type('o');type('u');type('n');type('t');type('=');type('\0'); 
....................     
....................       char dis0=(count/10000)+48; 
....................       char dis1=((count%10000)/1000)+48; 
....................       char dis2=(((count%10000)%1000)/100)+48; 
....................       char dis3=((((count%10000)%1000)%100)/10)+48; 
....................       char dis4=((((count%10000)%1000)%100)%10)+48; 
....................        
....................       dis0 = dis0 == '0' ? '\0' : dis0; 
....................       type(dis0); type(dis1); type(dis2); type(dis3); type(dis4); 
....................     
.................... } 
.................... // val_adc is value of analog ot digital from mcp3208 
.................... // line is position of LCD display 
.................... // ch is channel of ADC 
.................... void show_adc(int16 val_adc,int line,int ch){ 
....................        
....................       val_adc=val_adc/16; 
....................           
....................       if(line==1) 
....................          setPosition(0); 
....................       else if(line==2) 
....................          setPosition(16); 
....................       else if(line==3){ 
....................          setPosition(15); 
....................          type('\0');} 
....................        else if(line==4){ 
....................          setPosition(31); 
....................          type('\0');} 
....................           
....................         
....................           
....................       type('A'); 
....................       type('D'); 
....................       type('C'); 
....................       type(ch+48); 
....................       type('\0'); 
....................       type('='); 
....................       type('\0'); 
....................        
....................        
....................        
.................... //!      unsigned char dis1=(val_adc/1000)+48; 
.................... //!      unsigned char dis2=((val_adc%1000)/100)+48; 
.................... //!      unsigned char dis3=(((val_adc%1000)%100)/10)+48; 
.................... //!      unsigned char dis4=(((val_adc%1000)%100)%10)+48; 
....................        
....................        
....................       char dis0=(val_adc/10000)+48; 
....................       char dis1=((val_adc%10000)/1000)+48; 
....................       char dis2=(((val_adc%10000)%1000)/100)+48; 
....................       char dis3=((((val_adc%10000)%1000)%100)/10)+48; 
....................       char dis4=((((val_adc%10000)%1000)%100)%10)+48; 
....................        
....................        
....................       type(dis0); 
....................       type(dis1); 
....................       type(dis2); 
....................       type(dis3); 
....................       type(dis4); 
.................... } 
....................  
.................... //!void main(void) { 
.................... //!   set_tris_c(0b00011001); 
.................... //!   init(); 
.................... //!    
.................... //!    
.................... //!   while(1){ 
.................... //!      if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!      } 
.................... //!   } 
.................... //!   int16 val_adc=0; 
.................... //!   int ch[8]={0,1,2,3,4,5,6,7}; 
.................... //!   set_tris_c(0b00011001); 
.................... //!   setup_adc(adc_off); 
.................... //!    
.................... //!   output_bit(PIN_A3,0); 
.................... //!   output_bit(PIN_A4,0); 
.................... //!    
.................... //!    
.................... //!   init();  //LCD Init 
.................... //!   adc_init(); 
.................... //!   int sw1=0; 
.................... //!   int sw2=0; 
.................... //!   int i=0; 
.................... //!    
.................... //!   while(1){ 
.................... //!    
.................... //!   if (gblTimeToUpdateScreen) { 
.................... //!         gblTimeToUpdateScreen = 0; 
.................... //!         updateScreen(); 
.................... //!      } 
.................... //!       
.................... //!      setPosition(0); 
.................... //!      type('I'); 
.................... //!      type('/'); 
.................... //!      type('O'); 
.................... //!      type(' '); 
.................... //!      type('M'); 
.................... //!      type('o'); 
.................... //!      type('d'); 
.................... //!      type('u'); 
.................... //!      type('l'); 
.................... //!      type('e'); 
.................... //!      type('\0'); 
.................... //!    
.................... //!       
.................... //!   val_adc=read_analog(ch[0]); 
.................... //!   show_adc(val_adc,2,ch[0]); 
.................... //!    
.................... //!   val_adc=read_analog(ch[1]); 
.................... //!   show_adc(val_adc,3,ch[1]); 
.................... //!    
.................... //!   val_adc=read_analog(ch[2]); 
.................... //!   show_adc(val_adc,4,ch[2]); 
.................... //!    
.................... //!   show_counter(i); 
.................... //!   sw1= input(PIN_A0); 
.................... //!   if(sw1==0){ 
.................... //!       
.................... //!      output_high(PIN_A3); 
.................... //!      delay_ms(150); 
.................... //!      i=i+1; 
.................... //!      if(i==100)i=0; 
.................... //!   } 
.................... //!   else { 
.................... //!      output_low(PIN_A3); 
.................... //!      delay_ms(20);} 
.................... //!    
.................... //!   //Switch Relay 
.................... //!   sw2=input(PIN_A1); 
.................... //!   if(sw2==0){ 
.................... //!      output_high(PIN_A4); 
.................... //!      delay_ms(250);} 
.................... //!   else{ 
.................... //!      output_low(PIN_A4); 
.................... //!      delay_ms(20);} 
.................... //!   } 
....................  
.................... //! } 
....................  
....................  
.................... #include <SHT15.c> 
.................... /* 
.................... #include <16F886.h> 
.................... #include <math.h> 
.................... #include <oasysLCD.c> 
.................... //#device adc=10 
....................  
.................... #FUSES NOWDT //No Watch Dog Timer 
.................... #FUSES HS //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT //No Power Up Timer 
.................... #FUSES MCLR //Master Clear pin enabled 
.................... #FUSES NOPROTECT //Code not protected from reading 
.................... #FUSES NOCPD //No EE protection 
.................... #FUSES NOBROWNOUT //No brownout reset 
.................... #FUSES IESO //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES BORV40 //Brownout reset at 4.0V 
.................... #FUSES NOWRT //Program memory not write protected 
....................  
.................... #use delay(clock=20000000) 
.................... */ 
....................  
....................  
.................... #define SHT1xDATA  PIN_A2 
.................... #define SHT1xSCK   PIN_A3 
.................... #define noACK 0  
.................... #define ACK   1  
....................  
.................... // SHT1x address=000 is currently supported  
.................... // SHT1x command code  
....................                             //adr  command  r/w  
.................... #define STATUS_REG_W 0x06   //000   0011    0  
.................... #define STATUS_REG_R 0x07   //000   0011    1  
.................... #define MEASURE_TEMP 0x03   //000   0001    1  
.................... #define MEASURE_HUMI 0x05   //000   0010    1  
.................... #define RESET        0x1E   //000   1111    0  
....................  
.................... // constant use for SHT1x Humidity Measurement  
.................... #define C1  -4.0  
.................... #define C2  0.0405  
.................... #define C3  -0.0000028  
....................  
.................... // constant use for SHT1x Temperature Measurement  
.................... #define D1  -40.0  
.................... #define D2  0.01  
....................  
.................... // constant use for SHT1x True Humidity Measurement  
.................... #define T1  0.01  
.................... #define T2  0.00008  
....................  
.................... //PIC16F6X8 
.................... //#define  CMCON   0x1F 
.................... //#define  PORTA    0x05 
.................... //#define  PORTB    0x06 
....................  
....................  
.................... void InitialChip(void) 
.................... { 
....................    setup_comparator(NC_NC_NC_NC);   //Input Digital 
*
0648:  BSF    03.6
0649:  CLRF   07
064A:  CLRF   08
064B:  CLRF   09
....................    set_tris_b(0B00000000); 
064C:  MOVLW  00
064D:  BSF    03.5
064E:  BCF    03.6
064F:  MOVWF  06
....................    set_tris_c(0B10000000); 
0650:  MOVLW  80
0651:  MOVWF  07
.................... } 
0652:  BCF    03.5
0653:  BCF    0A.3
0654:  BSF    0A.4
0655:  GOTO   078 (RETURN)
....................  
.................... //SHT1x Transmission Start condition 
.................... void SHTStart() 
.................... { 
....................    output_high(SHT1xDATA); 
*
066A:  BSF    03.5
066B:  BCF    05.2
066C:  BCF    03.5
066D:  BSF    05.2
....................    output_low(SHT1xSCK); 
066E:  BSF    03.5
066F:  BCF    05.3
0670:  BCF    03.5
0671:  BCF    05.3
....................    output_high(SHT1xSCK); 
0672:  BSF    03.5
0673:  BCF    05.3
0674:  BCF    03.5
0675:  BSF    05.3
....................    output_low(SHT1xDATA); 
0676:  BSF    03.5
0677:  BCF    05.2
0678:  BCF    03.5
0679:  BCF    05.2
....................    output_low(SHT1xSCK); 
067A:  BSF    03.5
067B:  BCF    05.3
067C:  BCF    03.5
067D:  BCF    05.3
....................    output_high(SHT1xSCK); 
067E:  BSF    03.5
067F:  BCF    05.3
0680:  BCF    03.5
0681:  BSF    05.3
....................    output_high(SHT1xDATA); 
0682:  BSF    03.5
0683:  BCF    05.2
0684:  BCF    03.5
0685:  BSF    05.2
....................    output_low(SHT1xSCK); 
0686:  BSF    03.5
0687:  BCF    05.3
0688:  BCF    03.5
0689:  BCF    05.3
.................... } 
068A:  RETURN
....................  
.................... // SHT1x Connection Reset: 
.................... void SHTConReset()  
.................... {  
....................    int i;  
....................     
....................    output_high(SHT1xDATA);  
068B:  BSF    03.5
068C:  BCF    05.2
068D:  BCF    03.5
068E:  BSF    05.2
....................     
....................    for (i=0; i<9; i++)  
068F:  BSF    03.5
0690:  CLRF   45
0691:  MOVF   45,W
0692:  SUBLW  08
0693:  BTFSS  03.0
0694:  GOTO   6A7
....................    {  
....................       output_high(SHT1xSCK);  
0695:  BCF    05.3
0696:  BCF    03.5
0697:  BSF    05.3
....................       delay_us(2);  
0698:  MOVLW  03
0699:  MOVWF  77
069A:  DECFSZ 77,F
069B:  GOTO   69A
....................       output_low(SHT1xSCK);  
069C:  BSF    03.5
069D:  BCF    05.3
069E:  BCF    03.5
069F:  BCF    05.3
....................       delay_us(2);  
06A0:  MOVLW  03
06A1:  MOVWF  77
06A2:  DECFSZ 77,F
06A3:  GOTO   6A2
....................    }  
06A4:  BSF    03.5
06A5:  INCF   45,F
06A6:  GOTO   691
....................    SHTStart();  
06A7:  BCF    03.5
06A8:  CALL   66A
.................... }  
06A9:  BCF    0A.3
06AA:  BSF    0A.4
06AB:  GOTO   082 (RETURN)
....................  
.................... // SHT1x Address & Command Mode with address=000  
.................... int SHTWrite(int Data)  
.................... {  
....................    int i;  
....................     
....................    for (i=0x80;i>0;i/=2)        //shift bit for masking data 
*
078C:  MOVLW  80
078D:  BSF    03.5
078E:  MOVWF  5F
078F:  MOVF   5F,F
0790:  BTFSC  03.2
0791:  GOTO   7B2
....................    {  
....................       if(i&Data) 
0792:  MOVF   5F,W
0793:  ANDWF  5E,W
0794:  BTFSC  03.2
0795:  GOTO   79B
....................       output_high(SHT1xDATA);  
0796:  BCF    05.2
0797:  BCF    03.5
0798:  BSF    05.2
....................       else   
0799:  GOTO   79E
079A:  BSF    03.5
....................       output_low(SHT1xDATA);  
079B:  BCF    05.2
079C:  BCF    03.5
079D:  BCF    05.2
....................        
....................       delay_us(2);               //Snend Clock each bit  
079E:  MOVLW  03
079F:  MOVWF  77
07A0:  DECFSZ 77,F
07A1:  GOTO   7A0
....................       output_high(SHT1xSCK);  
07A2:  BSF    03.5
07A3:  BCF    05.3
07A4:  BCF    03.5
07A5:  BSF    05.3
....................       delay_us(2);  
07A6:  MOVLW  03
07A7:  MOVWF  77
07A8:  DECFSZ 77,F
07A9:  GOTO   7A8
....................       output_low(SHT1xSCK);  
07AA:  BSF    03.5
07AB:  BCF    05.3
07AC:  BCF    03.5
07AD:  BCF    05.3
....................    }  
07AE:  BCF    03.0
07AF:  BSF    03.5
07B0:  RRF    5F,F
07B1:  GOTO   78F
....................     
....................    output_float(SHT1xDATA);     //Change DATA Line to Input  
07B2:  BSF    05.2
....................    delay_us(2);  
07B3:  MOVLW  03
07B4:  MOVWF  77
07B5:  DECFSZ 77,F
07B6:  GOTO   7B5
....................     
....................    output_high(SHT1xSCK);       //Clock for Acknowledge  
07B7:  BCF    05.3
07B8:  BCF    03.5
07B9:  BSF    05.3
....................    delay_us(2);  
07BA:  MOVLW  03
07BB:  MOVWF  77
07BC:  DECFSZ 77,F
07BD:  GOTO   7BC
....................     
....................    i= input(SHT1xDATA);         //Get Acknowledge 
07BE:  BSF    03.5
07BF:  BSF    05.2
07C0:  CLRF   5F
07C1:  BCF    03.5
07C2:  BTFSS  05.2
07C3:  GOTO   7C7
07C4:  BSF    03.5
07C5:  INCF   5F,F
07C6:  BCF    03.5
....................     
....................    output_low(SHT1xSCK);  
07C7:  BSF    03.5
07C8:  BCF    05.3
07C9:  BCF    03.5
07CA:  BCF    05.3
....................    delay_ms(250); 
07CB:  MOVLW  FA
07CC:  BSF    03.5
07CD:  MOVWF  60
07CE:  BCF    03.5
07CF:  CALL   656
....................    return (i); 
07D0:  BSF    03.5
07D1:  MOVF   5F,W
07D2:  MOVWF  78
.................... }  
07D3:  BCF    03.5
07D4:  RETURN
....................  
.................... //Read data from SHT1x 
.................... long SHTRead(void)  
.................... {  
....................    int i;  
....................    long lTmp,lVal1,lVal2,lValue;  
....................     
....................    lVal1=0; 
*
0800:  BSF    03.5
0801:  CLRF   62
0802:  CLRF   61
....................    lVal2=0;  
0803:  CLRF   64
0804:  CLRF   63
....................     
....................    //get MSB from SHT1x  
....................    for (i=0; i<8; i++)  
0805:  CLRF   5E
0806:  MOVF   5E,W
0807:  SUBLW  07
0808:  BTFSS  03.0
0809:  GOTO   025
....................    {  
....................       lVal1<<=1;  
080A:  BCF    03.0
080B:  RLF    61,F
080C:  RLF    62,F
....................       output_high(SHT1xSCK);          //Send Clock Hight 
080D:  BCF    05.3
080E:  BCF    03.5
080F:  BSF    05.3
....................       lTmp = input(SHT1xDATA);        //Read Data Bit  
0810:  BSF    03.5
0811:  BSF    05.2
0812:  CLRF   5F
0813:  BCF    03.5
0814:  BTFSS  05.2
0815:  GOTO   019
0816:  BSF    03.5
0817:  INCF   5F,F
0818:  BCF    03.5
0819:  BSF    03.5
081A:  CLRF   60
....................       output_low(SHT1xSCK);           //Send Clock Low 
081B:  BCF    05.3
081C:  BCF    03.5
081D:  BCF    05.3
....................        
....................       if(lTmp)  
081E:  BSF    03.5
081F:  MOVF   5F,W
0820:  IORWF  60,W
0821:  BTFSS  03.2
....................          lVal1|=1;                      //store in lVal1 
0822:  BSF    61.0
....................       }  
0823:  INCF   5E,F
0824:  GOTO   006
....................     
....................    //Acknowledge routine for Next byte 
....................    output_low(SHT1xDATA);  
0825:  BCF    05.2
0826:  BCF    03.5
0827:  BCF    05.2
....................    output_high(SHT1xSCK);  
0828:  BSF    03.5
0829:  BCF    05.3
082A:  BCF    03.5
082B:  BSF    05.3
....................     
....................    output_float(SHT1xDATA);         //Change to Input 
082C:  BSF    03.5
082D:  BSF    05.2
....................    output_low(SHT1xSCK);  
082E:  BCF    05.3
082F:  BCF    03.5
0830:  BCF    05.3
....................     
....................    //get LSB from SHT1x  
....................    for (i=0; i<8; i++)  
0831:  BSF    03.5
0832:  CLRF   5E
0833:  MOVF   5E,W
0834:  SUBLW  07
0835:  BTFSS  03.0
0836:  GOTO   052
....................    {  
....................       lVal2<<=1;  
0837:  BCF    03.0
0838:  RLF    63,F
0839:  RLF    64,F
....................       output_high(SHT1xSCK);          //Send Clock Hight  
083A:  BCF    05.3
083B:  BCF    03.5
083C:  BSF    05.3
....................       lTmp = input(SHT1xDATA);        //Read Data Bit   
083D:  BSF    03.5
083E:  BSF    05.2
083F:  CLRF   5F
0840:  BCF    03.5
0841:  BTFSS  05.2
0842:  GOTO   046
0843:  BSF    03.5
0844:  INCF   5F,F
0845:  BCF    03.5
0846:  BSF    03.5
0847:  CLRF   60
....................       //delay_us(2);  
....................       output_low(SHT1xSCK);           //Send Clock Low 
0848:  BCF    05.3
0849:  BCF    03.5
084A:  BCF    05.3
....................       //delay_us(2);  
....................        
....................       if(lTmp)  
084B:  BSF    03.5
084C:  MOVF   5F,W
084D:  IORWF  60,W
084E:  BTFSS  03.2
....................          lVal2|=1;                     //store in lVal2 
084F:  BSF    63.0
....................    }     
0850:  INCF   5E,F
0851:  GOTO   033
....................     
....................    lValue = make16(lVal1,lVal2);    //Makes a 16 bit number out of two 8 bit numbers. 
0852:  MOVF   61,W
0853:  MOVWF  66
0854:  MOVF   63,W
0855:  MOVWF  65
....................    return(lValue);  
0856:  MOVF   65,W
0857:  MOVWF  78
0858:  MOVF   66,W
0859:  MOVWF  79
.................... }  
085A:  BCF    03.5
085B:  RETURN
.................... // SHT1x Soft Reset  
.................... // resets the interface, clears the status register to default values  
.................... // wait minimum 11ms before next command  
.................... void SHTSoftReset()  
.................... {  
....................   SHTConReset();  
....................   SHTWrite(RESET);  
.................... }  
....................  
.................... // calculate dewpoint  
.................... float sht1x_calc_dewpoint(float fRh,float fTemp)  
.................... {  
....................    float fDewpoint;  
....................    float fLogEW;  
....................  
....................    fLogEW = ((7.5*fTemp)/(237.3+fTemp))+log10(fRh)-1.33923;  
....................    fDewpoint = ((0.66077-log10(fLogEW))*(237.3))/(log10(fLogEW)-8.16077);  
....................    return(fDewpoint);  
.................... }  
....................  
.................... float oa_Temp(void) 
.................... { 
....................    float fTemp_true;  
....................    long lValue_temp;  
....................    int R; 
....................  
....................    SHTStart();                            //@1 start transmission  
....................    R=SHTWrite(MEASURE_TEMP);           //@2 measure temperature  
....................    if(R==1) 
....................    { 
....................       //printf("Sensor Error\n\r"); 
....................       delay_ms(1000); 
....................    } 
....................     
....................    lValue_temp = SHTRead();  
....................     
....................    // temperature calculation  
....................    fTemp_true = (D1+(D2*lValue_temp));  
....................    fTemp_true = fTemp_true * 100; //float ot int 
....................    // delay 11ms before next command  
....................    delay_ms(12); 
....................     
....................    return(fTemp_true); 
.................... } 
....................  
.................... int oa_Temp_n_Humid(float& temp, float& humid) 
.................... { 
....................    float fRh_lin;  
....................    float fTemp_true;  
....................    float fRh_true; 
....................  
....................    long lValue_rh;  
....................    long lValue_temp;  
....................    int R; 
....................     
....................    SHTStart();                         //@1 start transmission  
*
1099:  BCF    0A.4
109A:  CALL   66A
109B:  BSF    0A.4
....................    R=SHTWrite(MEASURE_TEMP);           //@2 measure temperature  
109C:  MOVLW  03
109D:  BSF    03.5
109E:  MOVWF  5E
109F:  BCF    0A.4
10A0:  BCF    03.5
10A1:  CALL   78C
10A2:  BSF    0A.4
10A3:  MOVF   78,W
10A4:  BSF    03.5
10A5:  MOVWF  55
....................    if(R==1){ 
10A6:  DECFSZ 55,W
10A7:  GOTO   0B6
....................       delay_ms(1000); 
10A8:  MOVLW  04
10A9:  MOVWF  56
10AA:  MOVLW  FA
10AB:  MOVWF  60
10AC:  BCF    0A.4
10AD:  BCF    03.5
10AE:  CALL   656
10AF:  BSF    0A.4
10B0:  BSF    03.5
10B1:  DECFSZ 56,F
10B2:  GOTO   0AA
....................       return 1; 
10B3:  MOVLW  01
10B4:  MOVWF  78
10B5:  GOTO   342
....................    } 
....................     
....................    lValue_temp = SHTRead();  
10B6:  BCF    0A.4
10B7:  BSF    0A.3
10B8:  BCF    03.5
10B9:  CALL   000
10BA:  BSF    0A.4
10BB:  BCF    0A.3
10BC:  MOVF   79,W
10BD:  BSF    03.5
10BE:  MOVWF  54
10BF:  MOVF   78,W
10C0:  MOVWF  53
....................     
....................    // temperature calculation  
....................    fTemp_true = (D1+(D2*lValue_temp));  
10C1:  MOVF   54,W
10C2:  MOVWF  67
10C3:  MOVF   53,W
10C4:  MOVWF  66
10C5:  BCF    0A.4
10C6:  BCF    03.5
10C7:  CALL   7D5
10C8:  BSF    0A.4
10C9:  CLRF   27
10CA:  BTFSC  0B.7
10CB:  BSF    27.7
10CC:  BCF    0B.7
10CD:  MOVLW  0A
10CE:  BSF    03.6
10CF:  MOVWF  47
10D0:  MOVLW  D7
10D1:  MOVWF  46
10D2:  MOVLW  23
10D3:  MOVWF  45
10D4:  MOVLW  78
10D5:  MOVWF  44
10D6:  MOVF   7A,W
10D7:  MOVWF  4B
10D8:  MOVF   79,W
10D9:  MOVWF  4A
10DA:  MOVF   78,W
10DB:  MOVWF  49
10DC:  MOVF   77,W
10DD:  MOVWF  48
10DE:  BCF    0A.4
10DF:  BCF    03.6
10E0:  CALL   27E
10E1:  BSF    0A.4
10E2:  BTFSC  27.7
10E3:  BSF    0B.7
10E4:  BCF    03.1
10E5:  CLRF   27
10E6:  BTFSC  0B.7
10E7:  BSF    27.7
10E8:  BCF    0B.7
10E9:  BSF    03.6
10EA:  CLRF   3A
10EB:  CLRF   39
10EC:  MOVLW  A0
10ED:  MOVWF  38
10EE:  MOVLW  84
10EF:  MOVWF  37
10F0:  MOVF   7A,W
10F1:  MOVWF  3E
10F2:  MOVF   79,W
10F3:  MOVWF  3D
10F4:  MOVF   78,W
10F5:  MOVWF  3C
10F6:  MOVF   77,W
10F7:  MOVWF  3B
10F8:  BCF    0A.4
10F9:  BCF    03.6
10FA:  CALL   125
10FB:  BSF    0A.4
10FC:  BTFSC  27.7
10FD:  BSF    0B.7
10FE:  MOVF   7A,W
10FF:  BSF    03.5
1100:  MOVWF  4C
1101:  MOVF   79,W
1102:  MOVWF  4B
1103:  MOVF   78,W
1104:  MOVWF  4A
1105:  MOVF   77,W
1106:  MOVWF  49
....................     
....................    // delay 11ms before next command  
....................    delay_ms(12);  
1107:  MOVLW  0C
1108:  MOVWF  60
1109:  BCF    0A.4
110A:  BCF    03.5
110B:  CALL   656
110C:  BSF    0A.4
....................     
....................    // start transmission  
....................    SHTStart();  
110D:  BCF    0A.4
110E:  CALL   66A
110F:  BSF    0A.4
....................     
....................    // measure relative humidity  
....................    SHTWrite(MEASURE_HUMI); 
1110:  MOVLW  05
1111:  BSF    03.5
1112:  MOVWF  5E
1113:  BCF    0A.4
1114:  BCF    03.5
1115:  CALL   78C
1116:  BSF    0A.4
....................    lValue_rh = SHTRead();  
1117:  BCF    0A.4
1118:  BSF    0A.3
1119:  CALL   000
111A:  BSF    0A.4
111B:  BCF    0A.3
111C:  MOVF   79,W
111D:  BSF    03.5
111E:  MOVWF  52
111F:  MOVF   78,W
1120:  MOVWF  51
....................  
....................    // relative humidity calculation  
....................    fRh_lin = (C1+(C2*lValue_rh)+(C3*lValue_rh*lValue_rh));  
1121:  MOVF   52,W
1122:  MOVWF  67
1123:  MOVF   51,W
1124:  MOVWF  66
1125:  BCF    0A.4
1126:  BCF    03.5
1127:  CALL   7D5
1128:  BSF    0A.4
1129:  CLRF   27
112A:  BTFSC  0B.7
112B:  BSF    27.7
112C:  BCF    0B.7
112D:  MOVLW  54
112E:  BSF    03.6
112F:  MOVWF  47
1130:  MOVLW  E3
1131:  MOVWF  46
1132:  MOVLW  25
1133:  MOVWF  45
1134:  MOVLW  7A
1135:  MOVWF  44
1136:  MOVF   7A,W
1137:  MOVWF  4B
1138:  MOVF   79,W
1139:  MOVWF  4A
113A:  MOVF   78,W
113B:  MOVWF  49
113C:  MOVF   77,W
113D:  MOVWF  48
113E:  BCF    0A.4
113F:  BCF    03.6
1140:  CALL   27E
1141:  BSF    0A.4
1142:  BTFSC  27.7
1143:  BSF    0B.7
1144:  BCF    03.1
1145:  CLRF   27
1146:  BTFSC  0B.7
1147:  BSF    27.7
1148:  BCF    0B.7
1149:  BSF    03.6
114A:  CLRF   3A
114B:  CLRF   39
114C:  MOVLW  80
114D:  MOVWF  38
114E:  MOVLW  81
114F:  MOVWF  37
1150:  MOVF   7A,W
1151:  MOVWF  3E
1152:  MOVF   79,W
1153:  MOVWF  3D
1154:  MOVF   78,W
1155:  MOVWF  3C
1156:  MOVF   77,W
1157:  MOVWF  3B
1158:  BCF    0A.4
1159:  BCF    03.6
115A:  CALL   125
115B:  BSF    0A.4
115C:  BTFSC  27.7
115D:  BSF    0B.7
115E:  MOVF   77,W
115F:  BSF    03.5
1160:  MOVWF  56
1161:  MOVF   78,W
1162:  MOVWF  57
1163:  MOVF   79,W
1164:  MOVWF  58
1165:  MOVF   7A,W
1166:  MOVWF  59
1167:  MOVF   52,W
1168:  MOVWF  67
1169:  MOVF   51,W
116A:  MOVWF  66
116B:  BCF    0A.4
116C:  BCF    03.5
116D:  CALL   7D5
116E:  BSF    0A.4
116F:  CLRF   27
1170:  BTFSC  0B.7
1171:  BSF    27.7
1172:  BCF    0B.7
1173:  MOVLW  A2
1174:  BSF    03.6
1175:  MOVWF  47
1176:  MOVLW  E7
1177:  MOVWF  46
1178:  MOVLW  BB
1179:  MOVWF  45
117A:  MOVLW  6C
117B:  MOVWF  44
117C:  MOVF   7A,W
117D:  MOVWF  4B
117E:  MOVF   79,W
117F:  MOVWF  4A
1180:  MOVF   78,W
1181:  MOVWF  49
1182:  MOVF   77,W
1183:  MOVWF  48
1184:  BCF    0A.4
1185:  BCF    03.6
1186:  CALL   27E
1187:  BSF    0A.4
1188:  BTFSC  27.7
1189:  BSF    0B.7
118A:  MOVF   77,W
118B:  BSF    03.5
118C:  MOVWF  5A
118D:  MOVF   78,W
118E:  MOVWF  5B
118F:  MOVF   79,W
1190:  MOVWF  5C
1191:  MOVF   7A,W
1192:  MOVWF  5D
1193:  MOVF   52,W
1194:  MOVWF  67
1195:  MOVF   51,W
1196:  MOVWF  66
1197:  BCF    0A.4
1198:  BCF    03.5
1199:  CALL   7D5
119A:  BSF    0A.4
119B:  CLRF   27
119C:  BTFSC  0B.7
119D:  BSF    27.7
119E:  BCF    0B.7
119F:  BSF    03.5
11A0:  MOVF   5D,W
11A1:  BCF    03.5
11A2:  BSF    03.6
11A3:  MOVWF  47
11A4:  BSF    03.5
11A5:  BCF    03.6
11A6:  MOVF   5C,W
11A7:  BCF    03.5
11A8:  BSF    03.6
11A9:  MOVWF  46
11AA:  BSF    03.5
11AB:  BCF    03.6
11AC:  MOVF   5B,W
11AD:  BCF    03.5
11AE:  BSF    03.6
11AF:  MOVWF  45
11B0:  BSF    03.5
11B1:  BCF    03.6
11B2:  MOVF   5A,W
11B3:  BCF    03.5
11B4:  BSF    03.6
11B5:  MOVWF  44
11B6:  MOVF   7A,W
11B7:  MOVWF  4B
11B8:  MOVF   79,W
11B9:  MOVWF  4A
11BA:  MOVF   78,W
11BB:  MOVWF  49
11BC:  MOVF   77,W
11BD:  MOVWF  48
11BE:  BCF    0A.4
11BF:  BCF    03.6
11C0:  CALL   27E
11C1:  BSF    0A.4
11C2:  BTFSC  27.7
11C3:  BSF    0B.7
11C4:  BCF    03.1
11C5:  CLRF   27
11C6:  BTFSC  0B.7
11C7:  BSF    27.7
11C8:  BCF    0B.7
11C9:  BSF    03.5
11CA:  MOVF   59,W
11CB:  BCF    03.5
11CC:  BSF    03.6
11CD:  MOVWF  3A
11CE:  BSF    03.5
11CF:  BCF    03.6
11D0:  MOVF   58,W
11D1:  BCF    03.5
11D2:  BSF    03.6
11D3:  MOVWF  39
11D4:  BSF    03.5
11D5:  BCF    03.6
11D6:  MOVF   57,W
11D7:  BCF    03.5
11D8:  BSF    03.6
11D9:  MOVWF  38
11DA:  BSF    03.5
11DB:  BCF    03.6
11DC:  MOVF   56,W
11DD:  BCF    03.5
11DE:  BSF    03.6
11DF:  MOVWF  37
11E0:  MOVF   7A,W
11E1:  MOVWF  3E
11E2:  MOVF   79,W
11E3:  MOVWF  3D
11E4:  MOVF   78,W
11E5:  MOVWF  3C
11E6:  MOVF   77,W
11E7:  MOVWF  3B
11E8:  BCF    0A.4
11E9:  BCF    03.6
11EA:  CALL   125
11EB:  BSF    0A.4
11EC:  BTFSC  27.7
11ED:  BSF    0B.7
11EE:  MOVF   7A,W
11EF:  BSF    03.5
11F0:  MOVWF  48
11F1:  MOVF   79,W
11F2:  MOVWF  47
11F3:  MOVF   78,W
11F4:  MOVWF  46
11F5:  MOVF   77,W
11F6:  MOVWF  45
....................    fRh_true = (((fTemp_true-25)*(T1+(T2*lValue_rh)))+fRh_lin); 
11F7:  BSF    03.1
11F8:  BCF    03.5
11F9:  CLRF   27
11FA:  BTFSC  0B.7
11FB:  BSF    27.7
11FC:  BCF    0B.7
11FD:  BSF    03.5
11FE:  MOVF   4C,W
11FF:  BCF    03.5
1200:  BSF    03.6
1201:  MOVWF  3A
1202:  BSF    03.5
1203:  BCF    03.6
1204:  MOVF   4B,W
1205:  BCF    03.5
1206:  BSF    03.6
1207:  MOVWF  39
1208:  BSF    03.5
1209:  BCF    03.6
120A:  MOVF   4A,W
120B:  BCF    03.5
120C:  BSF    03.6
120D:  MOVWF  38
120E:  BSF    03.5
120F:  BCF    03.6
1210:  MOVF   49,W
1211:  BCF    03.5
1212:  BSF    03.6
1213:  MOVWF  37
1214:  CLRF   3E
1215:  CLRF   3D
1216:  MOVLW  48
1217:  MOVWF  3C
1218:  MOVLW  83
1219:  MOVWF  3B
121A:  BCF    0A.4
121B:  BCF    03.6
121C:  CALL   125
121D:  BSF    0A.4
121E:  BTFSC  27.7
121F:  BSF    0B.7
1220:  MOVF   77,W
1221:  BSF    03.5
1222:  MOVWF  56
1223:  MOVF   78,W
1224:  MOVWF  57
1225:  MOVF   79,W
1226:  MOVWF  58
1227:  MOVF   7A,W
1228:  MOVWF  59
1229:  MOVF   52,W
122A:  MOVWF  67
122B:  MOVF   51,W
122C:  MOVWF  66
122D:  BCF    0A.4
122E:  BCF    03.5
122F:  CALL   7D5
1230:  BSF    0A.4
1231:  CLRF   27
1232:  BTFSC  0B.7
1233:  BSF    27.7
1234:  BCF    0B.7
1235:  MOVLW  AC
1236:  BSF    03.6
1237:  MOVWF  47
1238:  MOVLW  C5
1239:  MOVWF  46
123A:  MOVLW  27
123B:  MOVWF  45
123C:  MOVLW  71
123D:  MOVWF  44
123E:  MOVF   7A,W
123F:  MOVWF  4B
1240:  MOVF   79,W
1241:  MOVWF  4A
1242:  MOVF   78,W
1243:  MOVWF  49
1244:  MOVF   77,W
1245:  MOVWF  48
1246:  BCF    0A.4
1247:  BCF    03.6
1248:  CALL   27E
1249:  BSF    0A.4
124A:  BTFSC  27.7
124B:  BSF    0B.7
124C:  BCF    03.1
124D:  CLRF   27
124E:  BTFSC  0B.7
124F:  BSF    27.7
1250:  BCF    0B.7
1251:  MOVLW  0A
1252:  BSF    03.6
1253:  MOVWF  3A
1254:  MOVLW  D7
1255:  MOVWF  39
1256:  MOVLW  23
1257:  MOVWF  38
1258:  MOVLW  78
1259:  MOVWF  37
125A:  MOVF   7A,W
125B:  MOVWF  3E
125C:  MOVF   79,W
125D:  MOVWF  3D
125E:  MOVF   78,W
125F:  MOVWF  3C
1260:  MOVF   77,W
1261:  MOVWF  3B
1262:  BCF    0A.4
1263:  BCF    03.6
1264:  CALL   125
1265:  BSF    0A.4
1266:  BTFSC  27.7
1267:  BSF    0B.7
1268:  CLRF   27
1269:  BTFSC  0B.7
126A:  BSF    27.7
126B:  BCF    0B.7
126C:  BSF    03.5
126D:  MOVF   59,W
126E:  BCF    03.5
126F:  BSF    03.6
1270:  MOVWF  47
1271:  BSF    03.5
1272:  BCF    03.6
1273:  MOVF   58,W
1274:  BCF    03.5
1275:  BSF    03.6
1276:  MOVWF  46
1277:  BSF    03.5
1278:  BCF    03.6
1279:  MOVF   57,W
127A:  BCF    03.5
127B:  BSF    03.6
127C:  MOVWF  45
127D:  BSF    03.5
127E:  BCF    03.6
127F:  MOVF   56,W
1280:  BCF    03.5
1281:  BSF    03.6
1282:  MOVWF  44
1283:  MOVF   7A,W
1284:  MOVWF  4B
1285:  MOVF   79,W
1286:  MOVWF  4A
1287:  MOVF   78,W
1288:  MOVWF  49
1289:  MOVF   77,W
128A:  MOVWF  48
128B:  BCF    0A.4
128C:  BCF    03.6
128D:  CALL   27E
128E:  BSF    0A.4
128F:  BTFSC  27.7
1290:  BSF    0B.7
1291:  MOVF   77,W
1292:  BSF    03.5
1293:  MOVWF  56
1294:  MOVF   78,W
1295:  MOVWF  57
1296:  MOVF   79,W
1297:  MOVWF  58
1298:  MOVF   7A,W
1299:  MOVWF  59
129A:  BCF    03.1
129B:  BCF    03.5
129C:  CLRF   27
129D:  BTFSC  0B.7
129E:  BSF    27.7
129F:  BCF    0B.7
12A0:  BSF    03.5
12A1:  MOVF   59,W
12A2:  BCF    03.5
12A3:  BSF    03.6
12A4:  MOVWF  3A
12A5:  BSF    03.5
12A6:  BCF    03.6
12A7:  MOVF   58,W
12A8:  BCF    03.5
12A9:  BSF    03.6
12AA:  MOVWF  39
12AB:  BSF    03.5
12AC:  BCF    03.6
12AD:  MOVF   57,W
12AE:  BCF    03.5
12AF:  BSF    03.6
12B0:  MOVWF  38
12B1:  BSF    03.5
12B2:  BCF    03.6
12B3:  MOVF   56,W
12B4:  BCF    03.5
12B5:  BSF    03.6
12B6:  MOVWF  37
12B7:  BSF    03.5
12B8:  BCF    03.6
12B9:  MOVF   48,W
12BA:  BCF    03.5
12BB:  BSF    03.6
12BC:  MOVWF  3E
12BD:  BSF    03.5
12BE:  BCF    03.6
12BF:  MOVF   47,W
12C0:  BCF    03.5
12C1:  BSF    03.6
12C2:  MOVWF  3D
12C3:  BSF    03.5
12C4:  BCF    03.6
12C5:  MOVF   46,W
12C6:  BCF    03.5
12C7:  BSF    03.6
12C8:  MOVWF  3C
12C9:  BSF    03.5
12CA:  BCF    03.6
12CB:  MOVF   45,W
12CC:  BCF    03.5
12CD:  BSF    03.6
12CE:  MOVWF  3B
12CF:  BCF    0A.4
12D0:  BCF    03.6
12D1:  CALL   125
12D2:  BSF    0A.4
12D3:  BTFSC  27.7
12D4:  BSF    0B.7
12D5:  MOVF   7A,W
12D6:  BSF    03.5
12D7:  MOVWF  50
12D8:  MOVF   79,W
12D9:  MOVWF  4F
12DA:  MOVF   78,W
12DB:  MOVWF  4E
12DC:  MOVF   77,W
12DD:  MOVWF  4D
12DE:  BCF    03.5
12DF:  CLRF   27
12E0:  BTFSC  0B.7
12E1:  BSF    27.7
12E2:  BCF    0B.7
....................     
....................    temp = (fTemp_true * 100); 
12E3:  BSF    03.5
12E4:  MOVF   4C,W
12E5:  BCF    03.5
12E6:  BSF    03.6
12E7:  MOVWF  47
12E8:  BSF    03.5
12E9:  BCF    03.6
12EA:  MOVF   4B,W
12EB:  BCF    03.5
12EC:  BSF    03.6
12ED:  MOVWF  46
12EE:  BSF    03.5
12EF:  BCF    03.6
12F0:  MOVF   4A,W
12F1:  BCF    03.5
12F2:  BSF    03.6
12F3:  MOVWF  45
12F4:  BSF    03.5
12F5:  BCF    03.6
12F6:  MOVF   49,W
12F7:  BCF    03.5
12F8:  BSF    03.6
12F9:  MOVWF  44
12FA:  CLRF   4B
12FB:  CLRF   4A
12FC:  MOVLW  48
12FD:  MOVWF  49
12FE:  MOVLW  85
12FF:  MOVWF  48
1300:  BCF    0A.4
1301:  BCF    03.6
1302:  CALL   27E
1303:  BSF    0A.4
1304:  BTFSC  27.7
1305:  BSF    0B.7
1306:  MOVF   7A,W
1307:  BSF    03.5
1308:  MOVWF  3B
1309:  MOVF   79,W
130A:  MOVWF  3A
130B:  MOVF   78,W
130C:  MOVWF  39
130D:  MOVF   77,W
130E:  MOVWF  38
130F:  BCF    03.5
1310:  CLRF   27
1311:  BTFSC  0B.7
1312:  BSF    27.7
1313:  BCF    0B.7
....................    humid = (fRh_true * 100); 
1314:  BSF    03.5
1315:  MOVF   50,W
1316:  BCF    03.5
1317:  BSF    03.6
1318:  MOVWF  47
1319:  BSF    03.5
131A:  BCF    03.6
131B:  MOVF   4F,W
131C:  BCF    03.5
131D:  BSF    03.6
131E:  MOVWF  46
131F:  BSF    03.5
1320:  BCF    03.6
1321:  MOVF   4E,W
1322:  BCF    03.5
1323:  BSF    03.6
1324:  MOVWF  45
1325:  BSF    03.5
1326:  BCF    03.6
1327:  MOVF   4D,W
1328:  BCF    03.5
1329:  BSF    03.6
132A:  MOVWF  44
132B:  CLRF   4B
132C:  CLRF   4A
132D:  MOVLW  48
132E:  MOVWF  49
132F:  MOVLW  85
1330:  MOVWF  48
1331:  BCF    0A.4
1332:  BCF    03.6
1333:  CALL   27E
1334:  BSF    0A.4
1335:  BTFSC  27.7
1336:  BSF    0B.7
1337:  MOVF   7A,W
1338:  BSF    03.5
1339:  MOVWF  3F
133A:  MOVF   79,W
133B:  MOVWF  3E
133C:  MOVF   78,W
133D:  MOVWF  3D
133E:  MOVF   77,W
133F:  MOVWF  3C
....................    return 0; 
1340:  MOVLW  00
1341:  MOVWF  78
.................... } 
....................  
.................... /* 
.................... // Main Program  
.................... void main(void) {  
....................    float fRh_lin;  
....................    float fRh_true;  
....................    float fTemp_true;  
....................    float fDew_point;  
....................  
....................    long lValue_rh;  
....................    long lValue_temp;  
....................    int R; 
....................  
....................    InitialChip(); 
....................    delay_ms(200); 
....................  
....................    SHTConReset();  
....................  
....................    //usb_init(); 
....................  
....................    set_tris_c(0b00011001); 
....................    init(); 
....................     
....................     
....................    while (TRUE)  
....................    {  
.................... //      show_temp(oa_Temp()); 
....................       float temp, humid; 
....................       int error = oa_Temp_n_Humid(temp, humid); 
....................       if (error) continue; 
....................       show_temp(temp); 
....................       //delay_ms(1000);  
....................  
....................       SHTStart();                         //@1 start transmission  
....................       R=SHTWrite(MEASURE_TEMP);           //@2 measure temperature  
....................          if(R==1){ 
....................             //printf("Sensor Error\n\r"); 
....................             //printf("Sensor Error\n"); 
....................             delay_ms(1000); 
....................             continue; 
....................          } 
....................  
....................       lValue_temp = SHTRead();  
....................  
....................       // temperature calculation  
....................       fTemp_true = (D1+(D2*lValue_temp));  
....................  
....................       // delay 11ms before next command  
....................       delay_ms(12);  
....................  
....................       // start transmission  
....................       SHTStart();  
....................  
....................       // measure relative humidity  
....................       SHTWrite(MEASURE_HUMI);  
....................       lValue_rh = SHTRead();  
....................  
....................       // relative humidity calculation  
....................       fRh_lin = (C1+(C2*lValue_rh)+(C3*lValue_rh*lValue_rh));  
....................       fRh_true = (((fTemp_true-25)*(T1+(T2*lValue_rh)))+fRh_lin);  
....................  
....................       // dewpoint calculation  
....................       fDew_point = sht1x_calc_dewpoint(fRh_true,fTemp_true);  
....................     
....................       //printf("T=%3.2f C\r\n",fTemp_true); 
....................       //printf("H=%3.2f%%\r\n",fRh_true); 
....................       //printf("Dew Point: %3.6fC \r\n\r\n",fDew_point); 
....................        
....................       show_temp(fTemp_true*100); 
....................    } 
.................... }  
.................... */ 
....................  
.................... #include <myMCP3208.c> 
.................... ////////////////// Driver for MCP3208 A/D Converter //////////////////////// 
.................... ////                                                   //// 
.................... ////  adc_init()                                          //// 
.................... ////      Call after power up                                 //// 
.................... ////                                                   //// 
.................... ////  value = read_analog_mcp( channel, mode )                     //// 
.................... ////      Read an analog channel                              //// 
.................... ////      0 through 7 and select                              //// 
.................... ////      differential (0) or                                 //// 
.................... ////      single (1) mode                                    //// 
.................... ////                                                   //// 
.................... ////  value = read_analog( channel )                           //// 
.................... ////      Read an analog channel                              //// 
.................... ////      0 through 7 in   single mode                           //// 
.................... ////                                                   //// 
.................... ////  convert_to_volts( value,  string )                        //// 
.................... ////      Fills in string with                              //// 
.................... ////      the true voltage in                                 //// 
.................... ////      the form 0.000                                    //// 
.................... ////                                                   //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //#ifndef MCP3208_CS 
....................  
.................... #define MCP3208_CLK  PIN_A5 
.................... #define MCP3208_DOUT PIN_C0 
.................... #define MCP3208_DIN  PIN_C1 
.................... #define MCP3208_CS   PIN_C2 
....................  
.................... //#endif 
....................  
....................  
....................  
.................... void adc_init() { 
....................    output_high(MCP3208_CS); 
.................... } 
....................  
....................  
.................... void write_adc_byte(BYTE data_byte, BYTE number_of_bits) { 
....................    BYTE i; 
....................  
....................    delay_us(2); 
*
0AF2:  MOVLW  03
0AF3:  MOVWF  77
0AF4:  DECFSZ 77,F
0AF5:  GOTO   2F4
....................    for(i=0; i<number_of_bits; ++i) { 
0AF6:  CLRF   57
0AF7:  MOVF   56,W
0AF8:  SUBWF  57,W
0AF9:  BTFSC  03.0
0AFA:  GOTO   31A
....................       output_low(MCP3208_CLK); 
0AFB:  BCF    05.5
0AFC:  BCF    03.5
0AFD:  BCF    05.5
....................       if((data_byte & 1)==0) 
0AFE:  BSF    03.5
0AFF:  MOVF   55,W
0B00:  ANDLW  01
0B01:  BTFSS  03.2
0B02:  GOTO   307
....................          output_low(MCP3208_DIN); 
0B03:  BCF    03.5
0B04:  BCF    07.1
....................       else 
0B05:  GOTO   309
0B06:  BSF    03.5
....................          output_high(MCP3208_DIN); 
0B07:  BCF    03.5
0B08:  BSF    07.1
....................       data_byte=data_byte>>1; 
0B09:  BCF    03.0
0B0A:  BSF    03.5
0B0B:  RRF    55,F
....................       delay_us(50); 
0B0C:  MOVLW  53
0B0D:  MOVWF  77
0B0E:  DECFSZ 77,F
0B0F:  GOTO   30E
....................       output_high(MCP3208_CLK); 
0B10:  BCF    05.5
0B11:  BCF    03.5
0B12:  BSF    05.5
....................       delay_us(50); 
0B13:  MOVLW  53
0B14:  MOVWF  77
0B15:  DECFSZ 77,F
0B16:  GOTO   315
....................    } 
0B17:  BSF    03.5
0B18:  INCF   57,F
0B19:  GOTO   2F7
.................... } 
....................  
....................  
.................... BYTE read_adc_byte(BYTE number_of_bits) { 
....................    BYTE i,data; 
....................  
....................    data=0; 
*
0A76:  BSF    03.5
0A77:  CLRF   57
....................    for(i=0;i<number_of_bits;++i) { 
0A78:  CLRF   56
0A79:  MOVF   55,W
0A7A:  SUBWF  56,W
0A7B:  BTFSC  03.0
0A7C:  GOTO   295
....................       output_low(MCP3208_CLK); 
0A7D:  BCF    05.5
0A7E:  BCF    03.5
0A7F:  BCF    05.5
....................       delay_us(50); 
0A80:  MOVLW  53
0A81:  MOVWF  77
0A82:  DECFSZ 77,F
0A83:  GOTO   282
....................       shift_left(&data,1,input(MCP3208_DOUT)); 
0A84:  BTFSC  07.0
0A85:  GOTO   288
0A86:  BCF    03.0
0A87:  GOTO   289
0A88:  BSF    03.0
0A89:  BSF    03.5
0A8A:  RLF    57,F
....................       output_high(MCP3208_CLK); 
0A8B:  BCF    05.5
0A8C:  BCF    03.5
0A8D:  BSF    05.5
....................       delay_us(50); 
0A8E:  MOVLW  53
0A8F:  MOVWF  77
0A90:  DECFSZ 77,F
0A91:  GOTO   290
....................    } 
0A92:  BSF    03.5
0A93:  INCF   56,F
0A94:  GOTO   279
....................    return(data); 
0A95:  MOVF   57,W
0A96:  MOVWF  78
.................... } 
0A97:  BCF    03.5
0A98:  RETURN
....................  
....................  
.................... long int read_analog_mcp(BYTE channel, BYTE mode) { 
....................    int l; 
....................    long int h; 
....................    BYTE ctrl_bits; 
....................  
....................    delay_us(200); 
*
0AAD:  MOVLW  C8
0AAE:  MOVWF  55
....................  
....................    if(mode!=0) 
*
0ABD:  MOVF   50,F
0ABE:  BTFSC  03.2
0ABF:  GOTO   2C2
....................       mode=1; 
0AC0:  MOVLW  01
0AC1:  MOVWF  50
....................  
....................    output_low(MCP3208_CLK); 
0AC2:  BCF    05.5
0AC3:  BCF    03.5
0AC4:  BCF    05.5
....................    output_high(MCP3208_DIN); 
0AC5:  BSF    07.1
....................    output_low(MCP3208_CS); 
0AC6:  BCF    07.2
....................  
....................    if(channel==1)               // Change so MSB of channel # 
0AC7:  BSF    03.5
0AC8:  DECFSZ 4F,W
0AC9:  GOTO   2CD
....................       ctrl_bits=4;            //      is in LSB place 
0ACA:  MOVLW  04
0ACB:  MOVWF  54
....................    else if(channel==3) 
0ACC:  GOTO   2E4
0ACD:  MOVF   4F,W
0ACE:  SUBLW  03
0ACF:  BTFSS  03.2
0AD0:  GOTO   2D4
....................       ctrl_bits=6; 
0AD1:  MOVLW  06
0AD2:  MOVWF  54
....................    else if(channel==4) 
0AD3:  GOTO   2E4
0AD4:  MOVF   4F,W
0AD5:  SUBLW  04
0AD6:  BTFSS  03.2
0AD7:  GOTO   2DB
....................       ctrl_bits=1; 
0AD8:  MOVLW  01
0AD9:  MOVWF  54
....................    else if(channel==6) 
0ADA:  GOTO   2E4
0ADB:  MOVF   4F,W
0ADC:  SUBLW  06
0ADD:  BTFSS  03.2
0ADE:  GOTO   2E2
....................       ctrl_bits=3; 
0ADF:  MOVLW  03
0AE0:  MOVWF  54
....................    else 
0AE1:  GOTO   2E4
....................       ctrl_bits=channel; 
0AE2:  MOVF   4F,W
0AE3:  MOVWF  54
....................  
....................    ctrl_bits=ctrl_bits<<1; 
0AE4:  BCF    03.0
0AE5:  RLF    54,F
....................  
....................    if(mode==1)                  // In single mode 
0AE6:  DECFSZ 50,W
0AE7:  GOTO   2EA
....................       ctrl_bits |= 1; 
0AE8:  BSF    54.0
....................    else                        // In differential mode 
0AE9:  GOTO   2EB
....................       ctrl_bits &= 0xfe; 
0AEA:  BCF    54.0
....................  
....................    ctrl_bits=ctrl_bits<<1;      // Shift so LSB is start bit 
0AEB:  BCF    03.0
0AEC:  RLF    54,F
....................    ctrl_bits |= 1; 
0AED:  BSF    54.0
....................  
....................    write_adc_byte( ctrl_bits, 7);   // Send the control bits 
0AEE:  MOVF   54,W
0AEF:  MOVWF  55
0AF0:  MOVLW  07
0AF1:  MOVWF  56
....................  
....................    h=read_adc_byte(8); 
*
0B1A:  MOVLW  08
0B1B:  MOVWF  55
0B1C:  BCF    03.5
0B1D:  CALL   276
0B1E:  BSF    03.5
0B1F:  CLRF   53
0B20:  MOVF   78,W
0B21:  MOVWF  52
....................    l=read_adc_byte(4)<<4; 
0B22:  MOVLW  04
0B23:  MOVWF  55
0B24:  BCF    03.5
0B25:  CALL   276
0B26:  SWAPF  78,W
0B27:  BSF    03.5
0B28:  MOVWF  51
0B29:  MOVLW  F0
0B2A:  ANDWF  51,F
....................  
....................    output_high(MCP3208_CS); 
0B2B:  BCF    03.5
0B2C:  BSF    07.2
....................  
....................    return((h<<8)|l); 
0B2D:  BSF    03.5
0B2E:  CLRF   55
0B2F:  MOVF   55,W
0B30:  IORWF  51,W
0B31:  MOVWF  77
0B32:  MOVF   52,W
0B33:  MOVWF  7A
0B34:  MOVF   77,W
0B35:  MOVWF  78
0B36:  MOVF   52,W
0B37:  MOVWF  79
.................... } 
....................  
....................  
.................... long int read_analog( BYTE channel )   // Auto specifies single mode 
.................... { 
....................    return read_analog_mcp( channel, 1); 
*
0AA9:  MOVF   4E,W
0AAA:  MOVWF  4F
0AAB:  MOVLW  01
0AAC:  MOVWF  50
*
0B38:  MOVF   79,W
.................... } 
....................  
....................  
.................... void convert_to_volts( long int data, char volts[6]) { 
....................    BYTE i, d, div_h, div_l; 
....................    long int temp,div; 
....................  
....................    div=0x3330; 
....................  
....................    for(i=0;i<=4;i++) { 
....................      temp=data/div; 
....................      volts[i]=(BYTE)temp+'0'; 
....................      if(i==0) { 
....................        volts[1]='.'; 
....................        i++; 
....................      } 
....................      temp=div*(BYTE)temp; 
....................      data=data-temp; 
....................      div=div/10; 
....................    } 
....................    volts[i]='\0'; 
.................... } 
....................  
.................... #include <ultrasonic.c> 
.................... //!#include <16F886.h> 
.................... //!#include <math.h> 
.................... //! 
.................... //!//#device adc=10 
.................... //! 
.................... //!#FUSES NOWDT //No Watch Dog Timer 
.................... //!#FUSES HS //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... //!#FUSES NOPUT //No Power Up Timer 
.................... //!#FUSES MCLR //Master Clear pin enabled 
.................... //!#FUSES NOPROTECT //Code not protected from reading 
.................... //!#FUSES NOCPD //No EE protection 
.................... //!#FUSES NOBROWNOUT //No brownout reset 
.................... //!#FUSES IESO //Internal External Switch Over mode enabled 
.................... //!#FUSES FCMEN //Fail-safe clock monitor enabled 
.................... //!#FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... //!#FUSES NODEBUG //No Debug mode for ICD 
.................... //!#FUSES BORV40 //Brownout reset at 4.0V 
.................... //!#FUSES NOWRT //Program memory not write protected 
.................... //! 
.................... //!#use delay(clock=20000000) 
.................... //#use RS232 (baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
....................  
.................... //#include <oasysLCD.c> 
.................... //#include <myMCP3208.c> 
.................... //#include <SHT15.c> 
.................... //#include <Pressure.c> 
.................... //#include <usb_cdc.h> 
....................  
.................... int16 oa_Sonic(void){ 
....................   int16 value_sonic = 0; 
....................   int16 total_sonic = 0; 
....................   int i; 
....................   for( i=1;i<=10;i++){ 
....................       value_sonic = read_analog(0); 
....................       total_sonic = total_sonic + value_sonic; 
....................   } 
....................   total_sonic = total_sonic / 10; //avg loop 100 
....................   total_sonic = total_sonic / 4;  //12 Bit to 10 Bit 
....................   return(total_sonic); 
.................... } 
....................  
....................  
.................... float foa_Sonic(void){ 
*
0A99:  BSF    03.5
0A9A:  CLRF   48
0A9B:  CLRF   47
0A9C:  CLRF   46
0A9D:  CLRF   45
0A9E:  CLRF   4C
0A9F:  CLRF   4B
0AA0:  CLRF   4A
0AA1:  CLRF   49
....................   float value_sonic = 0; 
....................   float total_sonic = 0; 
....................   int i; 
....................   for( i=1;i<=10;i++){ 
0AA2:  MOVLW  01
0AA3:  MOVWF  4D
0AA4:  MOVF   4D,W
0AA5:  SUBLW  0A
0AA6:  BTFSS  03.0
0AA7:  GOTO   390
....................       value_sonic = read_analog(0); 
0AA8:  CLRF   4E
*
0B39:  MOVF   79,W
0B3A:  MOVWF  67
0B3B:  MOVF   78,W
0B3C:  MOVWF  66
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   7D5
0B40:  BSF    0A.3
0B41:  MOVF   7A,W
0B42:  BSF    03.5
0B43:  MOVWF  48
0B44:  MOVF   79,W
0B45:  MOVWF  47
0B46:  MOVF   78,W
0B47:  MOVWF  46
0B48:  MOVF   77,W
0B49:  MOVWF  45
....................       total_sonic = total_sonic + value_sonic; 
0B4A:  BCF    03.1
0B4B:  BCF    03.5
0B4C:  CLRF   27
0B4D:  BTFSC  0B.7
0B4E:  BSF    27.7
0B4F:  BCF    0B.7
0B50:  BSF    03.5
0B51:  MOVF   4C,W
0B52:  BCF    03.5
0B53:  BSF    03.6
0B54:  MOVWF  3A
0B55:  BSF    03.5
0B56:  BCF    03.6
0B57:  MOVF   4B,W
0B58:  BCF    03.5
0B59:  BSF    03.6
0B5A:  MOVWF  39
0B5B:  BSF    03.5
0B5C:  BCF    03.6
0B5D:  MOVF   4A,W
0B5E:  BCF    03.5
0B5F:  BSF    03.6
0B60:  MOVWF  38
0B61:  BSF    03.5
0B62:  BCF    03.6
0B63:  MOVF   49,W
0B64:  BCF    03.5
0B65:  BSF    03.6
0B66:  MOVWF  37
0B67:  BSF    03.5
0B68:  BCF    03.6
0B69:  MOVF   48,W
0B6A:  BCF    03.5
0B6B:  BSF    03.6
0B6C:  MOVWF  3E
0B6D:  BSF    03.5
0B6E:  BCF    03.6
0B6F:  MOVF   47,W
0B70:  BCF    03.5
0B71:  BSF    03.6
0B72:  MOVWF  3D
0B73:  BSF    03.5
0B74:  BCF    03.6
0B75:  MOVF   46,W
0B76:  BCF    03.5
0B77:  BSF    03.6
0B78:  MOVWF  3C
0B79:  BSF    03.5
0B7A:  BCF    03.6
0B7B:  MOVF   45,W
0B7C:  BCF    03.5
0B7D:  BSF    03.6
0B7E:  MOVWF  3B
0B7F:  BCF    0A.3
0B80:  BCF    03.6
0B81:  CALL   125
0B82:  BSF    0A.3
0B83:  BTFSC  27.7
0B84:  BSF    0B.7
0B85:  MOVF   7A,W
0B86:  BSF    03.5
0B87:  MOVWF  4C
0B88:  MOVF   79,W
0B89:  MOVWF  4B
0B8A:  MOVF   78,W
0B8B:  MOVWF  4A
0B8C:  MOVF   77,W
0B8D:  MOVWF  49
....................   } 
0B8E:  INCF   4D,F
0B8F:  GOTO   2A4
0B90:  BCF    03.5
0B91:  CLRF   27
0B92:  BTFSC  0B.7
0B93:  BSF    27.7
0B94:  BCF    0B.7
....................   total_sonic = total_sonic / 10; //avg loop 100 
0B95:  BSF    03.5
0B96:  MOVF   4C,W
0B97:  BCF    03.5
0B98:  BSF    03.6
0B99:  MOVWF  3A
0B9A:  BSF    03.5
0B9B:  BCF    03.6
0B9C:  MOVF   4B,W
0B9D:  BCF    03.5
0B9E:  BSF    03.6
0B9F:  MOVWF  39
0BA0:  BSF    03.5
0BA1:  BCF    03.6
0BA2:  MOVF   4A,W
0BA3:  BCF    03.5
0BA4:  BSF    03.6
0BA5:  MOVWF  38
0BA6:  BSF    03.5
0BA7:  BCF    03.6
0BA8:  MOVF   49,W
0BA9:  BCF    03.5
0BAA:  BSF    03.6
0BAB:  MOVWF  37
0BAC:  CLRF   3E
0BAD:  CLRF   3D
0BAE:  MOVLW  20
0BAF:  MOVWF  3C
0BB0:  MOVLW  82
0BB1:  MOVWF  3B
0BB2:  BCF    0A.3
0BB3:  BCF    03.6
0BB4:  CALL   059
0BB5:  BSF    0A.3
0BB6:  BTFSC  27.7
0BB7:  BSF    0B.7
0BB8:  MOVF   7A,W
0BB9:  BSF    03.5
0BBA:  MOVWF  4C
0BBB:  MOVF   79,W
0BBC:  MOVWF  4B
0BBD:  MOVF   78,W
0BBE:  MOVWF  4A
0BBF:  MOVF   77,W
0BC0:  MOVWF  49
0BC1:  BCF    03.5
0BC2:  CLRF   27
0BC3:  BTFSC  0B.7
0BC4:  BSF    27.7
0BC5:  BCF    0B.7
....................   total_sonic = total_sonic / 4;  //12 Bit to 10 Bit 
0BC6:  BSF    03.5
0BC7:  MOVF   4C,W
0BC8:  BCF    03.5
0BC9:  BSF    03.6
0BCA:  MOVWF  3A
0BCB:  BSF    03.5
0BCC:  BCF    03.6
0BCD:  MOVF   4B,W
0BCE:  BCF    03.5
0BCF:  BSF    03.6
0BD0:  MOVWF  39
0BD1:  BSF    03.5
0BD2:  BCF    03.6
0BD3:  MOVF   4A,W
0BD4:  BCF    03.5
0BD5:  BSF    03.6
0BD6:  MOVWF  38
0BD7:  BSF    03.5
0BD8:  BCF    03.6
0BD9:  MOVF   49,W
0BDA:  BCF    03.5
0BDB:  BSF    03.6
0BDC:  MOVWF  37
0BDD:  CLRF   3E
0BDE:  CLRF   3D
0BDF:  CLRF   3C
0BE0:  MOVLW  81
0BE1:  MOVWF  3B
0BE2:  BCF    0A.3
0BE3:  BCF    03.6
0BE4:  CALL   059
0BE5:  BSF    0A.3
0BE6:  BTFSC  27.7
0BE7:  BSF    0B.7
0BE8:  MOVF   7A,W
0BE9:  BSF    03.5
0BEA:  MOVWF  4C
0BEB:  MOVF   79,W
0BEC:  MOVWF  4B
0BED:  MOVF   78,W
0BEE:  MOVWF  4A
0BEF:  MOVF   77,W
0BF0:  MOVWF  49
....................   return(total_sonic); 
0BF1:  MOVF   49,W
0BF2:  MOVWF  77
0BF3:  MOVF   4A,W
0BF4:  MOVWF  78
0BF5:  MOVF   4B,W
0BF6:  MOVWF  79
0BF7:  MOVF   4C,W
0BF8:  MOVWF  7A
.................... } 
0BF9:  BCF    03.5
0BFA:  BCF    0A.3
0BFB:  BSF    0A.4
0BFC:  GOTO   388 (RETURN)
....................  
....................  
....................  
.................... //!void main(void){ 
.................... //!    
.................... //!   set_tris_c(0b00011001); 
.................... //!   init(); 
.................... //!    
.................... //!   int16 value_sonic = 0; 
.................... //! 
.................... //!   while(true){ 
.................... //!     value_sonic = read_analog(1); 
.................... //!     value_sonic = value_sonic / 4; 
.................... //!     show_water(value_sonic); 
.................... //!   } 
.................... //!} 
....................  
....................  
.................... // global variables 
.................... int slaveState1=READY_FOR_ADDRESS;   // state machine variable 
.................... int valFromMaster=0;  // buffer for the byte received from the master 
.................... int sentCount=0;  // tracks the number times slave has sent data to the master 
....................  
....................  
.................... int watchdog=0; 
....................  
.................... float vTemp=0; 
.................... float vHumid=0; 
.................... float vSonic=0; 
....................  
.................... void send_letter_to_MASTER(char* text); 
....................  
.................... void main(void){ 
*
1000:  CLRF   04
1001:  BCF    03.7
1002:  MOVLW  1F
1003:  ANDWF  03,F
1004:  MOVLW  FF
1005:  MOVWF  28
1006:  BSF    28.3
1007:  MOVF   28,W
1008:  BSF    03.5
1009:  MOVWF  07
100A:  BCF    03.5
100B:  BSF    28.4
100C:  MOVF   28,W
100D:  BSF    03.5
100E:  MOVWF  07
100F:  MOVLW  B0
1010:  MOVWF  13
1011:  MOVLW  36
1012:  BCF    03.5
1013:  MOVWF  14
1014:  CLRF   2F
1015:  CLRF   30
1016:  CLRF   31
1017:  CLRF   32
1018:  CLRF   33
1019:  BCF    34.0
101A:  CLRF   56
101B:  CLRF   58
101C:  CLRF   57
101D:  CLRF   71
101E:  CLRF   72
101F:  MOVLW  FF
1020:  MOVWF  7E
1021:  MOVWF  7D
1022:  MOVWF  7C
1023:  MOVWF  7B
1024:  BSF    03.5
1025:  CLRF   25
1026:  CLRF   24
1027:  MOVLW  01
1028:  MOVWF  26
1029:  CLRF   27
102A:  CLRF   28
102B:  CLRF   29
102C:  CLRF   2D
102D:  CLRF   2C
102E:  CLRF   2B
102F:  CLRF   2A
1030:  CLRF   31
1031:  CLRF   30
1032:  CLRF   2F
1033:  CLRF   2E
1034:  CLRF   35
1035:  CLRF   34
1036:  CLRF   33
1037:  CLRF   32
1038:  MOVLW  03
1039:  MOVWF  36
103A:  BSF    03.6
103B:  MOVF   09,W
103C:  ANDLW  C0
103D:  MOVWF  09
103E:  BCF    03.6
103F:  BCF    1F.4
1040:  BCF    1F.5
1041:  MOVLW  00
1042:  BSF    03.6
1043:  MOVWF  08
1044:  BCF    03.5
1045:  CLRF   07
1046:  CLRF   08
1047:  CLRF   09
*
1073:  BSF    03.5
1074:  CLRF   37
....................    int count = 0; 
....................    InitialChip(); 
1075:  BCF    0A.4
1076:  BCF    03.5
1077:  GOTO   648
1078:  BSF    0A.4
....................    delay_ms(200); 
1079:  MOVLW  C8
107A:  BSF    03.5
107B:  MOVWF  60
107C:  BCF    0A.4
107D:  BCF    03.5
107E:  CALL   656
107F:  BSF    0A.4
....................    SHTConReset();  
1080:  BCF    0A.4
1081:  GOTO   68B
1082:  BSF    0A.4
....................    set_tris_c(0b00011001); 
1083:  MOVLW  19
1084:  BSF    03.5
1085:  MOVWF  07
....................    init(); 
1086:  BCF    0A.4
1087:  BCF    03.5
1088:  GOTO   6CE
1089:  BSF    0A.4
....................     
....................    //Pressure_init(); 
....................    output_low(PIN_A0); 
108A:  BSF    03.5
108B:  BCF    05.0
108C:  BCF    03.5
108D:  BCF    05.0
....................     
....................   //1 setup_adc_ports(NO_ANALOGS|VSS_VDD); 
....................   //2 setup_adc(ADC_CLOCK_DIV_2); 
....................    //setup_spi(SPI_SS_DISABLED); 
....................   //3 setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
....................   //4 setup_timer_1(T1_DISABLED); 
....................   //5 setup_timer_2(T2_DISABLED,0,1); 
....................   //6 setup_ccp1(CCP_OFF); 
....................   //7setup_comparator(NC_NC_NC_NC);// This device COMP currently not supported by the PICWizard 
....................  
....................    enable_interrupts(INT_SSP); 
108E:  BSF    03.5
108F:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
1090:  MOVLW  C0
1091:  BCF    03.5
1092:  IORWF  0B,F
....................     
....................      
....................    if (gblTimeToUpdateScreen)  
1093:  BTFSS  34.0
1094:  GOTO   099
....................    { 
....................       gblTimeToUpdateScreen = 0; 
1095:  BCF    34.0
....................       updateScreen(); 
1096:  BCF    0A.4
1097:  GOTO   728
1098:  BSF    0A.4
....................    } 
....................     
....................    while(true) 
....................    {                
....................      float temp, humid; 
....................      //int16 sonic; 
....................      float sonic; 
....................       
....................      int error = oa_Temp_n_Humid(temp, humid); 
*
1342:  MOVF   78,W
1343:  MOVWF  44
....................      if (error) continue; 
1344:  MOVF   44,F
1345:  BTFSC  03.2
1346:  GOTO   34A
1347:  BCF    03.5
1348:  GOTO   099
1349:  BSF    03.5
....................      //temp =3265; 
....................      //humid =6532; 
....................      show_temp(temp); 
134A:  MOVF   3B,W
134B:  MOVWF  48
134C:  MOVF   3A,W
134D:  MOVWF  47
134E:  MOVF   39,W
134F:  MOVWF  46
1350:  MOVF   38,W
1351:  MOVWF  45
1352:  BCF    0A.4
1353:  BSF    0A.3
1354:  BCF    03.5
1355:  CALL   05C
1356:  BSF    0A.4
1357:  BCF    0A.3
1358:  MOVF   79,W
1359:  BSF    03.5
135A:  MOVWF  46
135B:  MOVF   78,W
135C:  MOVWF  45
135D:  MOVF   46,W
135E:  MOVWF  48
135F:  MOVF   45,W
1360:  MOVWF  47
1361:  BCF    0A.4
1362:  BSF    0A.3
1363:  BCF    03.5
1364:  GOTO   0A4
1365:  BSF    0A.4
1366:  BCF    0A.3
....................      show_humid(humid); 
1367:  BSF    03.5
1368:  MOVF   3F,W
1369:  MOVWF  48
136A:  MOVF   3E,W
136B:  MOVWF  47
136C:  MOVF   3D,W
136D:  MOVWF  46
136E:  MOVF   3C,W
136F:  MOVWF  45
1370:  BCF    0A.4
1371:  BSF    0A.3
1372:  BCF    03.5
1373:  CALL   05C
1374:  BSF    0A.4
1375:  BCF    0A.3
1376:  MOVF   79,W
1377:  BSF    03.5
1378:  MOVWF  46
1379:  MOVF   78,W
137A:  MOVWF  45
137B:  MOVF   46,W
137C:  MOVWF  48
137D:  MOVF   45,W
137E:  MOVWF  47
137F:  BCF    0A.4
1380:  BSF    0A.3
1381:  BCF    03.5
1382:  GOTO   189
1383:  BSF    0A.4
1384:  BCF    0A.3
....................       
....................      //PC commented to change to Float 
....................      //sonic = oa_Sonic(); 
....................      //show_sonic(sonic); 
....................       
....................       
....................      sonic = foa_Sonic(); 
1385:  BCF    0A.4
1386:  BSF    0A.3
1387:  GOTO   299
1388:  BSF    0A.4
1389:  BCF    0A.3
138A:  MOVF   7A,W
138B:  BSF    03.5
138C:  MOVWF  43
138D:  MOVF   79,W
138E:  MOVWF  42
138F:  MOVF   78,W
1390:  MOVWF  41
1391:  MOVF   77,W
1392:  MOVWF  40
....................      //sonic = 6000/16-sonic; 
....................      show_sonic(sonic); 
1393:  MOVF   43,W
1394:  MOVWF  48
1395:  MOVF   42,W
1396:  MOVWF  47
1397:  MOVF   41,W
1398:  MOVWF  46
1399:  MOVF   40,W
139A:  MOVWF  45
139B:  BCF    0A.4
139C:  BSF    0A.3
139D:  BCF    03.5
139E:  CALL   05C
139F:  BSF    0A.4
13A0:  BCF    0A.3
13A1:  MOVF   79,W
13A2:  BSF    03.5
13A3:  MOVWF  46
13A4:  MOVF   78,W
13A5:  MOVWF  45
13A6:  MOVF   46,W
13A7:  MOVWF  48
13A8:  MOVF   45,W
13A9:  MOVWF  47
13AA:  BCF    0A.4
13AB:  BSF    0A.3
13AC:  BCF    03.5
13AD:  GOTO   3FD
13AE:  BSF    0A.4
13AF:  BCF    0A.3
....................       
....................       
....................      vTemp = temp; 
13B0:  BSF    03.5
13B1:  MOVF   3B,W
13B2:  MOVWF  2D
13B3:  MOVF   3A,W
13B4:  MOVWF  2C
13B5:  MOVF   39,W
13B6:  MOVWF  2B
13B7:  MOVF   38,W
13B8:  MOVWF  2A
....................      vHumid = humid; 
13B9:  MOVF   3F,W
13BA:  MOVWF  31
13BB:  MOVF   3E,W
13BC:  MOVWF  30
13BD:  MOVF   3D,W
13BE:  MOVWF  2F
13BF:  MOVF   3C,W
13C0:  MOVWF  2E
....................      vSonic = sonic; 
13C1:  MOVF   43,W
13C2:  MOVWF  35
13C3:  MOVF   42,W
13C4:  MOVWF  34
13C5:  MOVF   41,W
13C6:  MOVWF  33
13C7:  MOVF   40,W
13C8:  MOVWF  32
....................    } 
13C9:  BCF    03.5
13CA:  GOTO   099
.................... } 
....................  
....................  
.................... #INT_SSP 
.................... void ssp_interrupt() 
13CB:  SLEEP
.................... { 
....................    int state; 
....................    int inByte; 
....................  
....................  
....................    // Output of i2c_isr_state() 
....................    // 
....................    // 0         - Address match received with R/W bit clear, perform i2c_read( ) 
....................    //             to read the I2C address. 
....................    // 1-0x7F    - Master has written data; i2c_read() will immediately return the data 
....................    // 0x80      - Address match received with R/W bit set; perform i2c_read( ) to read 
....................    //             the I2C address, and use i2c_write( ) to pre-load the transmit buffer 
....................    //             for the next transaction (next I2C read performed by master will read 
....................    //             this byte). 
....................    // 0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to 
....................    //             pre-load the transmit buffer for the next transation (the next I2C 
....................    //             read performed by master will read this byte). 
....................  
....................    state = i2c_isr_state(); 
*
043A:  BSF    03.5
043B:  BTFSC  14.5
043C:  GOTO   440
043D:  CLRF   36
043E:  BTFSC  14.2
043F:  BSF    36.7
0440:  MOVF   36,W
0441:  INCF   36,F
0442:  BCF    03.5
0443:  BSF    03.6
0444:  MOVWF  13
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    //  Address match with bit 0 clear (master write to slave) 
....................    ////////////////////////////////////////////////////////////////// 
....................    if (state == 0) { 
0445:  MOVF   13,F
0446:  BTFSS  03.2
0447:  GOTO   460
....................       i2c_read();  // flush the device address in the rx buffer 
0448:  BCF    03.6
0449:  BCF    14.6
044A:  BTFSS  0C.3
044B:  GOTO   44A
044C:  MOVF   13,W
044D:  BSF    14.4
....................        
....................  
....................       // Fix any errors in the I2C communication 
....................       // if wrong state -> there must have been an error in the i2c comm 
....................       if (slaveState1 != READY_FOR_ADDRESS) { 
044E:  BSF    03.5
044F:  DECFSZ 26,W
0450:  GOTO   452
0451:  GOTO   45B
....................          // clear the error flag registers and re-enable the i2c bus 
....................          SSPEN = 0;   // disable i2c 
0452:  BCF    03.5
0453:  BCF    14.5
....................          SSPOV = 0;   // clear the receive overflow flag 
0454:  BCF    14.6
....................          WCOL = 0;    // clear the write collision flag 
0455:  BCF    14.7
....................  
....................          SSPEN = 1;   // re-enable i2c 
0456:  BSF    14.5
....................  
....................          slaveState1 = READY_FOR_ADDRESS; // reset the state 
0457:  MOVLW  01
0458:  BSF    03.5
0459:  MOVWF  26
....................     
....................  
....................          return; 
045A:  GOTO   641
....................  
....................       } 
....................     
....................       // if no error -> move forward to the next state 
....................       slaveState1=READY_FOR_CMD;     //device moves into command mode 
045B:  MOVLW  02
045C:  MOVWF  26
....................  
....................    } 
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    //  a byte has been recieved from the Master 
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    else if (state < 0x80) { 
045D:  GOTO   641
045E:  BCF    03.5
045F:  BSF    03.6
0460:  MOVF   13,W
0461:  SUBLW  7F
0462:  BTFSS  03.0
0463:  GOTO   49F
....................  
....................          inByte=i2c_read(); 
0464:  BCF    03.6
0465:  BCF    14.6
0466:  BTFSS  0C.3
0467:  GOTO   466
0468:  MOVF   13,W
0469:  BSF    14.4
046A:  BSF    03.6
046B:  MOVWF  14
....................  
....................          switch (slaveState1) { 
046C:  BSF    03.5
046D:  BCF    03.6
046E:  MOVF   26,W
046F:  XORLW  02
0470:  BCF    03.5
0471:  BTFSC  03.2
0472:  GOTO   477
0473:  XORLW  01
0474:  BTFSC  03.2
0475:  GOTO   48F
0476:  GOTO   498
....................  
....................             case READY_FOR_CMD: 
....................  
....................                switch (inByte) { 
0477:  BSF    03.6
0478:  MOVF   14,W
0479:  XORLW  01
047A:  BCF    03.6
047B:  BTFSC  03.2
047C:  GOTO   481
047D:  XORLW  03
047E:  BTFSC  03.2
047F:  GOTO   485
0480:  GOTO   48A
....................                 
....................                   case CMD_RECEIVE_A_BYTE_FROM_MASTER: 
....................                      slaveState1=READY_FOR_NUMBER;   
0481:  MOVLW  03
0482:  BSF    03.5
0483:  MOVWF  26
....................                      break; 
0484:  GOTO   48E
....................                   case CMD_SEND_TWO_BYTES_TO_MASTER: 
....................                      slaveState1=READY_TO_SEND;  
0485:  MOVLW  04
0486:  BSF    03.5
0487:  MOVWF  26
....................                      break; 
0488:  GOTO   48E
0489:  BCF    03.5
....................  
....................                   // reset the state if received an 
....................                   // unknown command 
....................                   default: 
....................                      slaveState1 = READY_FOR_ADDRESS; 
048A:  MOVLW  01
048B:  BSF    03.5
048C:  MOVWF  26
....................                      break; 
048D:  GOTO   48E
....................                } 
....................  
....................                break; 
048E:  GOTO   49C
....................  
....................             case READY_FOR_NUMBER: 
....................                valFromMaster=inByte; 
048F:  BSF    03.6
0490:  MOVF   14,W
0491:  BSF    03.5
0492:  BCF    03.6
0493:  MOVWF  27
....................                slaveState1=READY_FOR_ADDRESS; 
0494:  MOVLW  01
0495:  MOVWF  26
....................                break; 
0496:  GOTO   49C
0497:  BCF    03.5
....................  
....................             // reset the state if unknown state is detected 
....................             default: 
....................                slaveState1=READY_FOR_ADDRESS; 
0498:  MOVLW  01
0499:  BSF    03.5
049A:  MOVWF  26
....................                break; 
049B:  GOTO   49C
....................  
....................          } 
....................  
....................    } 
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    //  Address match with bit 0 set (slave write to master) 
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    else if (state == 0x80) { 
049C:  GOTO   641
049D:  BCF    03.5
049E:  BSF    03.6
049F:  MOVF   13,W
04A0:  SUBLW  80
04A1:  BTFSS  03.2
04A2:  GOTO   4BA
....................  
....................  
....................       i2c_read();  // flush the address byte 
04A3:  BCF    03.6
04A4:  BCF    14.6
04A5:  BTFSS  0C.3
04A6:  GOTO   4A5
04A7:  MOVF   13,W
04A8:  BSF    14.4
....................                       
....................       if (slaveState1 == READY_TO_SEND) { 
04A9:  BSF    03.5
04AA:  MOVF   26,W
04AB:  SUBLW  04
04AC:  BTFSS  03.2
04AD:  GOTO   4B7
....................  
....................             i2c_write(0x61); 
04AE:  MOVLW  61
04AF:  BCF    03.5
04B0:  BSF    03.6
04B1:  MOVWF  38
04B2:  BCF    03.6
04B3:  CALL   04A
....................             slaveState1=READY_TO_SEND_BYTE_2; 
04B4:  MOVLW  05
04B5:  BSF    03.5
04B6:  MOVWF  26
....................       } 
....................  
....................    } 
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    //  Master is ready to receive the next byte from slave 
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    else if (state > 0x80) { 
04B7:  GOTO   641
04B8:  BCF    03.5
04B9:  BSF    03.6
04BA:  MOVF   13,W
04BB:  SUBLW  80
04BC:  BTFSC  03.0
04BD:  GOTO   643
....................  
....................       if (slaveState1 == READY_TO_SEND_BYTE_2) { 
04BE:  BSF    03.5
04BF:  BCF    03.6
04C0:  MOVF   26,W
04C1:  SUBLW  05
04C2:  BTFSS  03.2
04C3:  GOTO   641
....................             //i2c_write(222); 
....................             
....................             char buf [32]; 
....................             memset(buf, 0, 32); 
04C4:  MOVLW  15
04C5:  MOVWF  04
04C6:  BSF    03.7
04C7:  BCF    03.5
04C8:  BSF    03.6
04C9:  CLRF   37
04CA:  MOVLW  20
04CB:  MOVWF  38
....................              
....................             vTemp = vTemp/100; 
*
04D4:  BSF    03.5
04D5:  BCF    03.6
04D6:  MOVF   2D,W
04D7:  BCF    03.5
04D8:  BSF    03.6
04D9:  MOVWF  3A
04DA:  BSF    03.5
04DB:  BCF    03.6
04DC:  MOVF   2C,W
04DD:  BCF    03.5
04DE:  BSF    03.6
04DF:  MOVWF  39
04E0:  BSF    03.5
04E1:  BCF    03.6
04E2:  MOVF   2B,W
04E3:  BCF    03.5
04E4:  BSF    03.6
04E5:  MOVWF  38
04E6:  BSF    03.5
04E7:  BCF    03.6
04E8:  MOVF   2A,W
04E9:  BCF    03.5
04EA:  BSF    03.6
04EB:  MOVWF  37
04EC:  CLRF   3E
04ED:  CLRF   3D
04EE:  MOVLW  48
04EF:  MOVWF  3C
04F0:  MOVLW  85
04F1:  MOVWF  3B
04F2:  BCF    03.6
04F3:  CALL   059
04F4:  MOVF   7A,W
04F5:  BSF    03.5
04F6:  MOVWF  2D
04F7:  MOVF   79,W
04F8:  MOVWF  2C
04F9:  MOVF   78,W
04FA:  MOVWF  2B
04FB:  MOVF   77,W
04FC:  MOVWF  2A
....................             vHumid = vHumid/100; 
04FD:  MOVF   31,W
04FE:  BCF    03.5
04FF:  BSF    03.6
0500:  MOVWF  3A
0501:  BSF    03.5
0502:  BCF    03.6
0503:  MOVF   30,W
0504:  BCF    03.5
0505:  BSF    03.6
0506:  MOVWF  39
0507:  BSF    03.5
0508:  BCF    03.6
0509:  MOVF   2F,W
050A:  BCF    03.5
050B:  BSF    03.6
050C:  MOVWF  38
050D:  BSF    03.5
050E:  BCF    03.6
050F:  MOVF   2E,W
0510:  BCF    03.5
0511:  BSF    03.6
0512:  MOVWF  37
0513:  CLRF   3E
0514:  CLRF   3D
0515:  MOVLW  48
0516:  MOVWF  3C
0517:  MOVLW  85
0518:  MOVWF  3B
0519:  BCF    03.6
051A:  CALL   059
051B:  MOVF   7A,W
051C:  BSF    03.5
051D:  MOVWF  31
051E:  MOVF   79,W
051F:  MOVWF  30
0520:  MOVF   78,W
0521:  MOVWF  2F
0522:  MOVF   77,W
0523:  MOVWF  2E
....................              
....................             //PC changed /100 from 1000 1:21 
....................             vSonic = vSonic/16; 
0524:  MOVF   35,W
0525:  BCF    03.5
0526:  BSF    03.6
0527:  MOVWF  3A
0528:  BSF    03.5
0529:  BCF    03.6
052A:  MOVF   34,W
052B:  BCF    03.5
052C:  BSF    03.6
052D:  MOVWF  39
052E:  BSF    03.5
052F:  BCF    03.6
0530:  MOVF   33,W
0531:  BCF    03.5
0532:  BSF    03.6
0533:  MOVWF  38
0534:  BSF    03.5
0535:  BCF    03.6
0536:  MOVF   32,W
0537:  BCF    03.5
0538:  BSF    03.6
0539:  MOVWF  37
053A:  CLRF   3E
053B:  CLRF   3D
053C:  CLRF   3C
053D:  MOVLW  83
053E:  MOVWF  3B
053F:  BCF    03.6
0540:  CALL   059
0541:  MOVF   7A,W
0542:  BSF    03.5
0543:  MOVWF  35
0544:  MOVF   79,W
0545:  MOVWF  34
0546:  MOVF   78,W
0547:  MOVWF  33
0548:  MOVF   77,W
0549:  MOVWF  32
....................             vSonic = vSonic/100; 
054A:  MOVF   35,W
054B:  BCF    03.5
054C:  BSF    03.6
054D:  MOVWF  3A
054E:  BSF    03.5
054F:  BCF    03.6
0550:  MOVF   34,W
0551:  BCF    03.5
0552:  BSF    03.6
0553:  MOVWF  39
0554:  BSF    03.5
0555:  BCF    03.6
0556:  MOVF   33,W
0557:  BCF    03.5
0558:  BSF    03.6
0559:  MOVWF  38
055A:  BSF    03.5
055B:  BCF    03.6
055C:  MOVF   32,W
055D:  BCF    03.5
055E:  BSF    03.6
055F:  MOVWF  37
0560:  CLRF   3E
0561:  CLRF   3D
0562:  MOVLW  48
0563:  MOVWF  3C
0564:  MOVLW  85
0565:  MOVWF  3B
0566:  BCF    03.6
0567:  CALL   059
0568:  MOVF   7A,W
0569:  BSF    03.5
056A:  MOVWF  35
056B:  MOVF   79,W
056C:  MOVWF  34
056D:  MOVF   78,W
056E:  MOVWF  33
056F:  MOVF   77,W
0570:  MOVWF  32
....................             vSonic = 6-vSonic;  
0571:  BSF    03.1
0572:  BCF    03.5
0573:  BSF    03.6
0574:  CLRF   3A
0575:  CLRF   39
0576:  MOVLW  40
0577:  MOVWF  38
0578:  MOVLW  81
0579:  MOVWF  37
057A:  BSF    03.5
057B:  BCF    03.6
057C:  MOVF   35,W
057D:  BCF    03.5
057E:  BSF    03.6
057F:  MOVWF  3E
0580:  BSF    03.5
0581:  BCF    03.6
0582:  MOVF   34,W
0583:  BCF    03.5
0584:  BSF    03.6
0585:  MOVWF  3D
0586:  BSF    03.5
0587:  BCF    03.6
0588:  MOVF   33,W
0589:  BCF    03.5
058A:  BSF    03.6
058B:  MOVWF  3C
058C:  BSF    03.5
058D:  BCF    03.6
058E:  MOVF   32,W
058F:  BCF    03.5
0590:  BSF    03.6
0591:  MOVWF  3B
0592:  BCF    03.6
0593:  CALL   125
0594:  MOVF   7A,W
0595:  BSF    03.5
0596:  MOVWF  35
0597:  MOVF   79,W
0598:  MOVWF  34
0599:  MOVF   78,W
059A:  MOVWF  33
059B:  MOVF   77,W
059C:  MOVWF  32
....................              
....................             //vTemp = 3.2; 
....................             sprintf(buf, "T=%.1f&H=%.1f&S=%.2f", vTemp, vHumid, vSonic); 
059D:  MOVLW  01
059E:  MOVWF  25
059F:  MOVLW  15
05A0:  MOVWF  24
05A1:  MOVLW  54
05A2:  BCF    03.5
05A3:  BSF    03.6
05A4:  MOVWF  44
05A5:  BCF    03.6
05A6:  CALL   26B
05A7:  MOVLW  3D
05A8:  BSF    03.6
05A9:  MOVWF  44
05AA:  BCF    03.6
05AB:  CALL   26B
05AC:  MOVLW  89
05AD:  MOVWF  04
05AE:  BSF    03.5
05AF:  MOVF   2D,W
05B0:  BCF    03.5
05B1:  BSF    03.6
05B2:  MOVWF  3A
05B3:  BSF    03.5
05B4:  BCF    03.6
05B5:  MOVF   2C,W
05B6:  BCF    03.5
05B7:  BSF    03.6
05B8:  MOVWF  39
05B9:  BSF    03.5
05BA:  BCF    03.6
05BB:  MOVF   2B,W
05BC:  BCF    03.5
05BD:  BSF    03.6
05BE:  MOVWF  38
05BF:  BSF    03.5
05C0:  BCF    03.6
05C1:  MOVF   2A,W
05C2:  BCF    03.5
05C3:  BSF    03.6
05C4:  MOVWF  37
05C5:  MOVLW  01
05C6:  MOVWF  3B
05C7:  BCF    03.6
05C8:  CALL   346
05C9:  MOVLW  26
05CA:  BSF    03.6
05CB:  MOVWF  44
05CC:  BCF    03.6
05CD:  CALL   26B
05CE:  MOVLW  48
05CF:  BSF    03.6
05D0:  MOVWF  44
05D1:  BCF    03.6
05D2:  CALL   26B
05D3:  MOVLW  3D
05D4:  BSF    03.6
05D5:  MOVWF  44
05D6:  BCF    03.6
05D7:  CALL   26B
05D8:  MOVLW  89
05D9:  MOVWF  04
05DA:  BSF    03.5
05DB:  MOVF   31,W
05DC:  BCF    03.5
05DD:  BSF    03.6
05DE:  MOVWF  3A
05DF:  BSF    03.5
05E0:  BCF    03.6
05E1:  MOVF   30,W
05E2:  BCF    03.5
05E3:  BSF    03.6
05E4:  MOVWF  39
05E5:  BSF    03.5
05E6:  BCF    03.6
05E7:  MOVF   2F,W
05E8:  BCF    03.5
05E9:  BSF    03.6
05EA:  MOVWF  38
05EB:  BSF    03.5
05EC:  BCF    03.6
05ED:  MOVF   2E,W
05EE:  BCF    03.5
05EF:  BSF    03.6
05F0:  MOVWF  37
05F1:  MOVLW  01
05F2:  MOVWF  3B
05F3:  BCF    03.6
05F4:  CALL   346
05F5:  MOVLW  26
05F6:  BSF    03.6
05F7:  MOVWF  44
05F8:  BCF    03.6
05F9:  CALL   26B
05FA:  MOVLW  53
05FB:  BSF    03.6
05FC:  MOVWF  44
05FD:  BCF    03.6
05FE:  CALL   26B
05FF:  MOVLW  3D
0600:  BSF    03.6
0601:  MOVWF  44
0602:  BCF    03.6
0603:  CALL   26B
0604:  MOVLW  89
0605:  MOVWF  04
0606:  BSF    03.5
0607:  MOVF   35,W
0608:  BCF    03.5
0609:  BSF    03.6
060A:  MOVWF  3A
060B:  BSF    03.5
060C:  BCF    03.6
060D:  MOVF   34,W
060E:  BCF    03.5
060F:  BSF    03.6
0610:  MOVWF  39
0611:  BSF    03.5
0612:  BCF    03.6
0613:  MOVF   33,W
0614:  BCF    03.5
0615:  BSF    03.6
0616:  MOVWF  38
0617:  BSF    03.5
0618:  BCF    03.6
0619:  MOVF   32,W
061A:  BCF    03.5
061B:  BSF    03.6
061C:  MOVWF  37
061D:  MOVLW  02
061E:  MOVWF  3B
061F:  BCF    03.6
0620:  CALL   346
....................             int len = 20;//strlen(buf); 
....................             int i; 
0621:  MOVLW  14
0622:  BSF    03.6
0623:  MOVWF  35
....................             for(i = 0; i < len; i += 1) 
0624:  CLRF   36
0625:  MOVF   35,W
0626:  SUBWF  36,W
0627:  BTFSC  03.0
0628:  GOTO   636
....................             { 
....................                i2c_write(buf[i]); 
0629:  MOVLW  15
062A:  ADDWF  36,W
062B:  MOVWF  04
062C:  BSF    03.7
062D:  MOVF   00,W
062E:  MOVWF  37
062F:  MOVWF  38
0630:  BCF    03.6
0631:  CALL   04A
....................             } 
0632:  MOVLW  01
0633:  BSF    03.6
0634:  ADDWF  36,F
0635:  GOTO   625
....................             i2c_write('\0'); 
0636:  CLRF   38
0637:  BCF    03.6
0638:  CALL   04A
....................             i2c_write('\0'); 
0639:  BSF    03.6
063A:  CLRF   38
063B:  BCF    03.6
063C:  CALL   04A
....................             slaveState1=READY_FOR_ADDRESS; 
063D:  MOVLW  01
063E:  BSF    03.5
063F:  MOVWF  26
....................             sentCount++; 
0640:  INCF   28,F
0641:  BCF    03.5
0642:  BSF    03.6
....................       } 
....................    } 
....................  
....................  
.................... } 
....................  
....................  
0643:  BCF    03.6
0644:  BCF    0C.3
0645:  BCF    0A.3
0646:  BCF    0A.4
0647:  GOTO   023

Configuration Fuses:
   Word  1: 2FC2   HS NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40
